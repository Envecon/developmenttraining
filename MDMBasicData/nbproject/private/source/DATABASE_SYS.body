CREATE OR REPLACE PACKAGE BODY DATABASE_SYS IS

-----------------------------------------------------------------------------
-------------------- PRIVATE DECLARATIONS -----------------------------------
-----------------------------------------------------------------------------

TYPE oracle_object_type IS TABLE OF VARCHAR2(30) INDEX BY BINARY_INTEGER;

xml_start_        CONSTANT VARCHAR2(3) := chr(38)||'#x';

xml_end_          CONSTANT VARCHAR2(1) := ';';

db_encoding_      CONSTANT VARCHAR2(64):= Get_Database_Charset;

crlf_             CONSTANT VARCHAR2(2) := chr(13)||chr(10);

first_calendar_persian_date_   CONSTANT DATE := to_date('1800-01-01', 'YYYY-MM-DD', 'NLS_CALENDAR=GREGORIAN');

first_calendar_gregorian_date_ CONSTANT DATE := to_date('0001-01-01', 'YYYY-MM-DD', 'NLS_CALENDAR=GREGORIAN');

last_calendar_persian_date_    CONSTANT DATE := to_date('2199-12-31', 'YYYY-MM-DD', 'NLS_CALENDAR=GREGORIAN');

last_calendar_gregorian_date_  CONSTANT DATE := to_date('9999-12-31', 'YYYY-MM-DD', 'NLS_CALENDAR=GREGORIAN');


-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION METHOD DECLARATIONS ---------------------
-----------------------------------------------------------------------------

PROCEDURE Analyze_Dictionary___ (
   method_           IN VARCHAR2 DEFAULT 'AUTOMATIC' );

PROCEDURE Analyze_Schema___ (
   schema_           IN VARCHAR2 DEFAULT USER,
   method_           IN VARCHAR2 DEFAULT 'AUTOMATIC',
   estimate_percent_ IN NUMBER   DEFAULT NULL );

PROCEDURE Calculate_Percent___ (
   percent_ OUT NUMBER );

PROCEDURE Gather_Index_Statistics___ (
   method_           IN VARCHAR2 DEFAULT 'AUTOMATIC',
   schema_           IN VARCHAR2 DEFAULT USER,
   index_name_       IN VARCHAR2,
   estimate_percent_ IN NUMBER   DEFAULT NULL );

PROCEDURE Gather_Table_Statistics___ (
   method_           IN VARCHAR2 DEFAULT 'AUTOMATIC',
   schema_           IN VARCHAR2 DEFAULT USER,
   table_name_       IN VARCHAR2,
   estimate_percent_ IN NUMBER   DEFAULT NULL,
   block_sample_     IN BOOLEAN  DEFAULT FALSE,
   cascade_          IN BOOLEAN  DEFAULT FALSE );

FUNCTION Get_Oracle_Index_Attr___ (
   index_name_ IN VARCHAR2 ) RETURN VARCHAR2;

FUNCTION Get_Instance_Values___ RETURN sys.v_$instance%ROWTYPE;

PROCEDURE Rebuild_Index___ (
   attr_       OUT VARCHAR2,
   index_name_ IN  VARCHAR2 );

PROCEDURE Rebuild_Unusable_Indexes___(
   table_name_  IN VARCHAR2,
   show_info_   IN BOOLEAN  DEFAULT TRUE );

PROCEDURE Validate_Character_Set___ (
   character_set_    IN VARCHAR2 );

PROCEDURE Validate_Index___ (
   attr_             OUT VARCHAR2,
   index_name_       IN  VARCHAR2,
   validation_date_  IN  DATE DEFAULT SYSDATE );

FUNCTION Get_Job_Info___ RETURN VARCHAR2;

PROCEDURE Execute_Task___ (
   table_name_     IN VARCHAR2,
   stmt_           IN VARCHAR2,
   chunk_size_     IN NUMBER DEFAULT 10000,
   parallel_level_ IN NUMBER DEFAULT 10,
   lu_             IN VARCHAR2);

FUNCTION Get_Init_Ora_Parameter___ (
   parameter_  IN VARCHAR2 ) RETURN VARCHAR2;

PROCEDURE Grant_All_Hud_Pres_Objects___ (
   role_  IN VARCHAR2 );

FUNCTION Has_Domain_Index___ (
   table_name_ IN VARCHAR2 ) RETURN BOOLEAN;

FUNCTION Is_Unicode_Character_Set___ (
   character_set_ IN VARCHAR2 ) RETURN BOOLEAN;

PROCEDURE Update_Rowkey___ (
   table_name_ IN VARCHAR2,
   lu_         IN VARCHAR2 );

PROCEDURE Alter_Table_Rowkey___ (
   table_name_ IN VARCHAR2,
   compile_    IN VARCHAR2 );

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PUBLIC METHODS -----------------------------
-----------------------------------------------------------------------------

FUNCTION Get_SQL_Trace_Dir  RETURN VARCHAR2
IS
   value_  v$diag_info.value%TYPE;
BEGIN
   SELECT value
   INTO value_
   FROM   v$diag_info
   WHERE  name = 'Diag Trace';
   RETURN   value_;
END Get_SQL_Trace_Dir;


PROCEDURE List_Sd_To_Enable (
   enable_sd_ IN VARCHAR2 )
IS
   search_domain_ search_domain_runtime_tab.search_domain%TYPE;
   CURSOR get_sd IS
      SELECT search_domain
      FROM search_domain_runtime_tab
      WHERE enabled = 'FALSE';
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'List_Sd_To_Enable');
   IF UPPER(SUBSTR(enable_sd_, 1, 1)) = 'Y' THEN
      OPEN get_sd;
      FETCH get_sd INTO search_domain_;
      WHILE get_sd%FOUND LOOP
         Dbms_Output.Put_Line('PROMPT Enabling Search Domain '||search_domain_);
         Dbms_Output.Put_Line('EXEC Application_Search_Admin_SYS.Enable_Search_Domain__('''||search_domain_||''');');
         FETCH get_sd INTO search_domain_;
      END LOOP;
      CLOSE get_sd;
   ELSE
      Dbms_Output.Put_Line('PROMPT Enabling Search Domains is not selected');
   END IF;
END List_Sd_To_Enable;


PROCEDURE List_Lobs_To_Convert (
   convert_lobs_ IN VARCHAR2 )
IS
   table_name_  user_tab_columns.table_name%TYPE;
   column_name_ user_tab_columns.column_name%TYPE;
   CURSOR get_lobs IS
      SELECT c.table_name, c.column_name
        FROM user_objects o, user_tab_columns c, user_lobs l
       WHERE o.object_name = c.table_name
         AND o.object_type = 'TABLE'
         AND o.temporary = 'N'
         AND SUBSTR(o.OBJECT_NAME, INSTR(o.OBJECT_NAME, '_', -1)) != '_OLD'
         AND NOT REGEXP_LIKE(SUBSTR(o.OBJECT_NAME, INSTR(o.OBJECT_NAME, '_', -1)+1),'[0..9]')
         AND c.table_name = l.table_name
         AND c.column_name = l.column_name
         AND (l.securefile = 'NO' OR l.in_row = 'NO')
         AND c.table_name NOT LIKE 'VMO%TAB'
         AND c.table_name NOT LIKE 'DR$%'
         AND NOT EXISTS (SELECT 1
                           FROM ctx_user_indexes t
                          WHERE t.idx_table = c.table_name
                            AND t.idx_text_name = c.column_name)
       ORDER BY c.table_name, c.column_name;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'List_Lobs_To_Convert');
   IF UPPER(SUBSTR(convert_lobs_, 1, 1)) = 'Y' THEN
      OPEN get_lobs;
      FETCH get_lobs INTO table_name_, column_name_;
      WHILE get_lobs%FOUND LOOP
         Dbms_Output.Put_Line('PROMPT Converting LOB column '||column_name_||' in table '||table_name_||' into securefiles');
         Dbms_Output.Put_Line('EXEC Installation_SYS.Alter_Lob_To_Securefile('''||table_name_||''', '''||column_name_||''', FALSE);');
         FETCH get_lobs INTO table_name_, column_name_;
      END LOOP;
      CLOSE get_lobs;
   ELSE
      Dbms_Output.Put_Line('PROMPT Converting LOB columns into securefiles is not selected');
   END IF;
END List_Lobs_To_Convert;


PROCEDURE List_Rowkeys_To_Enable (
   enable_rowkey_ IN VARCHAR2 )
IS
   table_name_ user_tab_columns.table_name%TYPE;
   found_      BOOLEAN := FALSE;
   CURSOR get_table IS
      SELECT table_name
      FROM user_tab_columns
      WHERE column_name = 'ROWKEY'
      AND Database_SYS.Is_Rowkey_Enabled_Table(table_name) = 'FALSE'
      AND table_name IN (SELECT object_name 
                         FROM user_objects 
                         WHERE object_type = 'TABLE'
                         AND SUBSTR(object_name, INSTR(object_name, '_', -1)) != '_OLD'
                         AND NOT REGEXP_LIKE(SUBSTR(object_name, INSTR(object_name, '_', -1)+1),'[0..9]'));
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'List_Rowkeys_To_Enable');
   IF UPPER(SUBSTR(enable_rowkey_, 1, 1)) = 'Y' THEN
      OPEN get_table;
      FETCH get_table INTO table_name_;
      WHILE get_table%FOUND LOOP
         IF found_ = FALSE THEN
            -- this is the first hit!!
            found_ := TRUE;
            Dbms_Output.Put_Line('EXEC Install_Tem_SYS.Alter_Job_Queue_Processes__(10);');
            Dbms_Output.Put_Line('EXEC Install_Tem_SYS.Disable_Dbms_Scheduler__(''FALSE'');');
         END IF;
         Dbms_Output.Put_Line('PROMPT Enabling rowkey for '||table_name_);
         Dbms_Output.Put_Line('EXEC Database_SYS.Enable_Rowkey_Table('''||table_name_||''');');
         FETCH get_table INTO table_name_;
      END LOOP;
      CLOSE get_table;
      IF found_ THEN
         Dbms_Output.Put_Line('EXEC Install_Tem_SYS.Disable_Dbms_Scheduler__(''TRUE'');');
         Dbms_Output.Put_Line('EXEC Install_Tem_SYS.Alter_Job_Queue_Processes__(0);');
      END IF;
   ELSE
      Dbms_Output.Put_Line('PROMPT Enabling Rowkeys for custom objects is not selected');
   END IF;
END List_Rowkeys_To_Enable;


PROCEDURE Enable_Rowkey_Table (
   table_name_ IN VARCHAR2 )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Enable_Rowkey_Table');
   IF (Is_Rowkey_Enabled_Table(table_name_) = Fnd_Boolean_API.DB_FALSE) THEN
      IF (NOT (TO_NUMBER(Get_Init_Ora_Parameter___('job_queue_processes')) > 4)) THEN
         Error_SYS.Appl_General(service_, 'INIT_PARAM: Initialization parameter "job_queue_processes" must be set to a value bigger than 4 in order to enable rowkey.');
      ELSE
         Update_Rowkey___(table_name_, service_);
         Alter_Table_Rowkey___(table_name_, 'FALSE');
      END IF;
   END IF;
END Enable_Rowkey_Table;


PROCEDURE Enable_All_Rowkeys
IS
      CURSOR get_table IS
   SELECT table_name
   FROM user_tab_columns
   WHERE column_name = 'ROWKEY'
   AND table_name IN (SELECT object_name 
                      FROM user_objects 
                      WHERE object_type = 'TABLE');

   TYPE tab_array IS TABLE OF VARCHAR2(30);
   tab_arr_                   tab_array;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Enable_All_Rowkeys');
   OPEN  get_table;
   FETCH get_table BULK COLLECT INTO tab_arr_;
   CLOSE get_table;
   -- Loop over tables
   FOR i IN Nvl(tab_arr_.First, 0)..Nvl(tab_arr_.Last, -1) LOOP
      Enable_Rowkey_Table(tab_arr_(i));
   END LOOP;
END Enable_All_Rowkeys;


PROCEDURE Update_Rowkeys
IS
   text_       install_tem_sys_tab.text4%TYPE;
   guid_       install_tem_sys_tab.guid%TYPE;
   do_compile_ BOOLEAN := FALSE;
   CURSOR get_rec IS
      SELECT log_id, text1, text2, text3
      FROM install_tem_sys_tab
      WHERE guid = guid_
      AND   text4 IS NULL
      AND   category = 'LU_INSTALLATION_SUPPORT';
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Update_Rowkeys');
   guid_ := Install_Tem_SYS.Get_Installation_Id_;
   FOR rec_ IN get_rec LOOP
      Assert_SYS.Assert_Is_Logical_Unit(rec_.text1);
      IF rec_.text2 = 'ENABLE_ROWKEY' THEN
         IF Is_Rowkey_Enabled__(rec_.text1) THEN
            text_ := 'Rowkey already enabled';
         ELSE
            BEGIN
               text_ := 'Rowkey enabled';
               Enable_Rowkey(rec_.text1, compile_ => 'FALSE');
               do_compile_ := TRUE;
            EXCEPTION
               WHEN OTHERS THEN
                  text_ := 'Error/warning when enabling rowkey. '||SUBSTR(SQLERRM, 1, 900);
            END;
         END IF;
      ELSIF rec_.text2 = 'DISABLE_ROWKEY' THEN
         IF Is_Rowkey_Enabled__(rec_.text1) THEN
            BEGIN
               text_ := 'Rowkey disabled';
               Disable_Rowkey(rec_.text1, 'FALSE');
               do_compile_ := TRUE;
            EXCEPTION
               WHEN OTHERS THEN
                  text_ := 'Error/warning when disabling rowkey. '||SUBSTR(SQLERRM, 1, 900);
            END;
         ELSE
            text_ := 'Rowkey already disabled';
         END IF;
      END IF;
      UPDATE install_tem_sys_tab
      SET text4 = text_,
          last_modified = SYSDATE
      WHERE log_id = rec_.log_id;
   END LOOP;
   IF do_compile_ THEN
      Compile_All_Invalid_Objects;
   END IF;
END Update_Rowkeys;


PROCEDURE Enable_Rowkey (
   lu_               IN VARCHAR2,
   online_           IN VARCHAR2 DEFAULT 'TRUE',
   execution_date_   IN DATE DEFAULT NULL,
   compile_          IN VARCHAR2 DEFAULT 'TRUE' )
IS
   table_name_ VARCHAR2(30) := Dictionary_Sys.Get_Base_Table_Name(lu_);
   
   PROCEDURE Submit_Task___ (
      lu_               IN VARCHAR2,
      execution_date_   IN DATE )
   IS
      schedule_id_   NUMBER;
      start_date_    DATE       := execution_date_;
      seq_no_        NUMBER;
      next_execution_date_ DATE := execution_date_;
   BEGIN
      Batch_SYS.New_Batch_Schedule(schedule_id_,
                                   next_execution_date_,
                                   start_date_,
                                   NULL,
                                   'Enable Rowkey for ' || lu_,
                                   'DATABASE_SYS.ENABLE_ROWKEY',
                                   'TRUE',
                                   'ON '||to_char(execution_date_, 'YYYY-MM-DD')||' AT '||to_char(execution_date_, 'HH24:MI'));
      Batch_SYS.New_Batch_Schedule_Param(seq_no_, schedule_id_, 'LU_', lu_);
      Batch_SYS.New_Batch_Schedule_Param(seq_no_, schedule_id_, 'ONLINE_', 'TRUE');
      Batch_SYS.New_Batch_Schedule_Param(seq_no_, schedule_id_, 'EXECUTION_DATE_', execution_date_);
   END Submit_Task___;

   PROCEDURE Execute_Background___ (
      lu_               IN VARCHAR2 )
   IS
      id_      NUMBER;
      attr_    VARCHAR2(2000);
   BEGIN
      Client_SYS.Add_To_Attr('LU_', lu_, attr_);
      Client_SYS.Add_To_Attr('ONLINE_', 'TRUE', attr_);
      Transaction_SYS.Deferred_Call(id_, 'DATABASE_SYS.ENABLE_ROWKEY', Argument_Type_API.DB_NORMAL_PARAMETER, attr_, 'Enable rowkey for '||lu_);
   END Execute_Background___;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Enable_Rowkey');
   Transaction_SYS.Log_Progress_Info('Starting');
   -- Make possibility to run as background job
      IF (Dictionary_SYS.Get_Objkey_Info(lu_) = 'NONE') THEN
         Error_SYS.Appl_General(lu_, 'LU_NO_OBJKEY: LU :P1 is a LU that is designed without any ROWKEY, so the LU can''t be enabled.', lu_);
      END IF;
   IF (table_name_ IS NULL) THEN
      Error_SYS.Appl_General(lu_, 'LU_NO_TABLE: LU :P1 is a LU without any table so it can''t be enabled.', lu_);
   END IF;
   -- Check if rowkey column exists
   IF (NOT Column_Exist(table_name_, 'ROWKEY')) THEN
      Error_SYS.Appl_General(lu_, 'NO_ROWKEY: LU :P1 has no column ROWKEY so it can''t be enabled.', lu_);
   END IF;
   -- Check if rowkey constraint exists
   IF (NOT Constraint_Exist(substr(table_name_, 1, length(table_name_) - 4 ) || '_RK')) THEN
      Error_SYS.Appl_General(lu_, 'NO_CONSTRAINT: LU :P1 has no unique constraint on ROWKEY so it can''t be enabled.', lu_);
   END IF;
   -- Check if rowkey already is enabled
   IF (Is_Rowkey_Enabled__(lu_)) THEN
      Error_SYS.Appl_General(lu_, 'LU_ENABLED: LU :P1 is already enabled.', lu_);
   ELSE
      IF (online_ = 'TRUE') THEN
      -- Check if job_queue_processes is set to something bigger that 4, this functionality needs a value bigger than 4
         IF (NOT (TO_NUMBER(Get_Init_Ora_Parameter___('job_queue_processes')) > 4)) THEN
            Error_SYS.Appl_General(lu_, 'INIT_PARAM: Initialization parameter "job_queue_processes" must be set to a value bigger than 4 in order to enable rowkey.');
         ELSE
            Update_Rowkey___(table_name_, lu_);
            Alter_Table_Rowkey___(table_name_, compile_);
         END IF;
      ELSE
         IF (execution_date_ IS NOT NULL) THEN
            Submit_Task___(lu_, execution_date_);
         ELSE
            Execute_Background___(lu_);
         END IF;
      END IF;
   END IF;
   Transaction_SYS.Log_Progress_Info('Finished');
END Enable_Rowkey;


PROCEDURE Disable_Rowkey (
   lu_      IN VARCHAR2,
   compile_ IN VARCHAR2 DEFAULT 'TRUE' )
IS
   table_name_ VARCHAR2(30) := Dictionary_Sys.Get_Base_Table_Name(lu_);
   PROCEDURE Alter_Table_Rowkey___ (
      table_name_ IN VARCHAR2,
      compile_    IN VARCHAR2 )
   IS
      column_  Installation_SYS.Colrec;
   BEGIN
      column_ := Set_Column_Values('ROWKEY', 'VARCHAR2(50)', 'Y', 'NULL', NULL, 'D');
      Alter_Table_Column(table_name_, 'MODIFY', column_);
      IF compile_ = 'TRUE' THEN
         Transaction_SYS.Deferred_Call('Database_SYS.Compile_All_Invalid_Objects', null, 'Compile invalid objects after disabling rowkey for '||lu_);
      END IF;
   END Alter_Table_Rowkey___;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Disable_Rowkey');
   --
   IF Dictionary_SYS.Check_Custom_Object(lu_) THEN
      Error_SYS.Appl_General(service_, 'LU_CF: LU :P1 has Custom Objects connected to it.', lu_);
   END IF;
   -- Make possibility to run as background job
   IF (table_name_ IS NULL) THEN
      Error_SYS.Appl_General(lu_, 'LU_NO_TABLE_D: LU :P1 is a LU without any table so it can''t be disabled.', lu_);
   END IF;
   -- Check if rowkey already is disabled
   IF (Is_Rowkey_Enabled__(lu_)) THEN
      Alter_Table_Rowkey___(table_name_, compile_);
   ELSE
      Error_SYS.Appl_General(lu_, 'LU_DISABLED: LU :P1 is already disabled.', lu_);
   END IF;
END Disable_Rowkey;


FUNCTION Is_Rowkey_Enabled (
   lu_   IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   CASE (Is_Rowkey_Enabled__(lu_))
   WHEN TRUE THEN
      RETURN('TRUE');
   WHEN FALSE THEN
      RETURN('FALSE');
   ELSE
      RETURN(NULL);
   END CASE;
END Is_Rowkey_Enabled;


FUNCTION Is_Rowmovement_Enabled (
   table_name_   IN VARCHAR2 ) RETURN BOOLEAN
IS

BEGIN
   RETURN(Installation_SYS.Is_Rowmovement_Enabled(table_name_));
END Is_Rowmovement_Enabled;


PROCEDURE Log_Detail_Time_Stamp (
   module_ IN VARCHAR2,
   type_   IN VARCHAR2,
   what_   IN VARCHAR2 )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Log_Detail_Time_Stamp');
   Installation_SYS.Log_Detail_Time_Stamp(module_, type_, what_);
END Log_Detail_Time_Stamp;


FUNCTION Get_Installation_Mode RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Get_Installation_Mode);
END Get_Installation_Mode;


PROCEDURE Add_Lob_Column (
   table_name_  IN VARCHAR2,
   column_      IN ColRec,
   show_info_   IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Add_Lob_Column');
   Installation_SYS.Add_Lob_Column(table_name_, column_, show_info_);
END Add_Lob_Column;


PROCEDURE Alter_Lob_Column (
   table_name_  IN VARCHAR2,
   column_      IN ColRec,
   show_info_   IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Add_Lob_Column');
   Installation_SYS.Alter_Lob_Column(table_name_, column_, show_info_);
END Alter_Lob_Column;


PROCEDURE Alter_Long_Column_To_Lob (
   table_name_       IN VARCHAR2,
   column_name_      IN VARCHAR2,
   tablespace_       IN VARCHAR2,
   logging_          IN BOOLEAN DEFAULT TRUE,
   show_info_        IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Alter_Long_Column_To_Lob');
   Installation_SYS.Alter_Long_Column_To_Lob(table_name_, column_name_, tablespace_, logging_, show_info_);
END Alter_Long_Column_To_Lob;


PROCEDURE Alter_Table (
   table_name_    IN VARCHAR2,
   columns_       IN ColumnTabType,
   show_info_     IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Alter_Table');
   Installation_SYS.Alter_Table(table_name_, columns_, show_info_);
END Alter_Table;


PROCEDURE Alter_Table_Rowmovement (
   table_name_    IN VARCHAR2,
   enable_        IN BOOLEAN,
   show_info_     IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Alter_Table_Rowmovement');
   Installation_SYS.Alter_Table_Rowmovement(table_name_, show_info_);
END Alter_Table_Rowmovement;


PROCEDURE Alter_Table_Column (
   table_name_  IN VARCHAR2,
   alter_type_  IN VARCHAR2,
   column_      IN ColRec,
   show_info_   IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Alter_Table_Column');
   Installation_SYS.Alter_Table_Column(table_name_, alter_type_, column_, show_info_);
END Alter_Table_Column;


PROCEDURE Analyze_Object (
   type_             IN VARCHAR2 DEFAULT 'TABLE',
   schema_           IN VARCHAR2 DEFAULT USER,
   object_name_      IN VARCHAR2,
   method_           IN VARCHAR2 DEFAULT 'AUTOMATIC',
   estimate_percent_ IN NUMBER   DEFAULT NULL,
   cascade_          IN VARCHAR2 DEFAULT 'FALSE' )
IS
   cascade_local_ BOOLEAN;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Analyze_Object');
   IF type_ = 'TABLE' THEN
      IF cascade_ = 'TRUE' THEN
         cascade_local_ := TRUE;
      ELSE
         cascade_local_ := FALSE;
      END IF;
      Gather_Table_Statistics___ (method_           => method_,
                                  schema_           => schema_,
                                  table_name_       => object_name_,
                                  estimate_percent_ => estimate_percent_,
                                  cascade_          => cascade_local_);
   ELSE
      Gather_Index_Statistics___ (method_           => method_,
                                  schema_           => schema_,
                                  index_name_       => object_name_,
                                  estimate_percent_ => estimate_percent_);
   END IF;
END Analyze_Object;


FUNCTION Check_System_Privilege (
   privilege_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_privilege IS
      SELECT  1
      FROM    user_sys_privs
      WHERE   privilege = UPPER(privilege_);
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Check_System_Privilege');
   OPEN  check_privilege;
   FETCH check_privilege INTO dummy_;
   IF (check_privilege%FOUND) THEN
      CLOSE check_privilege;
      RETURN TRUE;
   ELSE
      CLOSE check_privilege;
      RETURN FALSE;
   END IF;
END Check_System_Privilege;


FUNCTION Column_Exist (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Column_Exist(table_name_, column_name_));
END Column_Exist;


FUNCTION Component_Exist (
   module_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
        FROM module_tab
       WHERE module = module_
         AND version IS NOT NULL
         AND version NOT IN ('?', '*');
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN(TRUE);
   END IF;
   CLOSE exist_control;
   RETURN(FALSE);
END Component_Exist;


FUNCTION Constraint_Exist (
   constraint_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Constraint_Exist(constraint_name_));
END Constraint_Exist;


FUNCTION Context_Exist (
   context_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Context_Exist(context_name_, Fnd_Session_API.Get_App_Owner));
END Context_Exist;


PROCEDURE Create_Constraint (
   table_name_      IN VARCHAR2,
   constraint_name_ IN VARCHAR2,
   columns_         IN ColumnTabType,
   type_            IN VARCHAR2 DEFAULT 'P',
   tablespace_      IN VARCHAR2 DEFAULT NULL,
   storage_         IN VARCHAR2 DEFAULT NULL,
   replace_         IN BOOLEAN  DEFAULT TRUE,
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Constraint');
   Installation_SYS.Create_Constraint(table_name_,
                                      constraint_name_,
                                      columns_,
                                      type_,
                                      tablespace_,
                                      storage_,
                                      replace_,
                                      show_info_);
END Create_Constraint;


PROCEDURE Create_Directory (
   directory_name_  IN VARCHAR2,
   path_            IN VARCHAR2,
   read_grant_      IN BOOLEAN  DEFAULT TRUE,
   write_grant_     IN BOOLEAN  DEFAULT TRUE,
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Directory');
   Installation_SYS.Create_Directory(directory_name_, path_, read_grant_, write_grant_, show_info_);
END Create_Directory;


PROCEDURE Create_Index (
   table_name_      IN VARCHAR2,
   index_name_      IN VARCHAR2,
   columns_         IN ColumnTabType,
   type_            IN VARCHAR2 DEFAULT 'N',
   tablespace_      IN VARCHAR2 DEFAULT NULL,
   storage_         IN VARCHAR2 DEFAULT NULL,
   replace_         IN BOOLEAN  DEFAULT TRUE,
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Index');
   Installation_SYS.Create_Index(table_name_,
                                 index_name_,
                                 columns_,
                                 type_,
                                 tablespace_,
                                 storage_,
                                 replace_,
                                 show_info_);
END Create_Index;


PROCEDURE Create_Sequence (
   sequence_     IN VARCHAR2,
   parameters_   IN VARCHAR2,
   show_info_    IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Sequence');
   Installation_SYS.Create_Sequence(sequence_,
                                    parameters_,
                                    show_info_);
END Create_Sequence;


PROCEDURE Create_Table (
   table_name_    IN VARCHAR2,
   columns_       IN ColumnTabType,
   tablespace_    IN VARCHAR2 DEFAULT NULL,
   storage_       IN VARCHAR2 DEFAULT NULL,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Table');
   Installation_SYS.Create_Table(table_name_,
                                 columns_,
                                 tablespace_,
                                 storage_,
                                 show_info_);
END Create_Table;


PROCEDURE Create_Table_Iot (
   table_name_    IN VARCHAR2,
   columns_       IN ColumnTabType,
   primary_key_   IN ColumnTabType,
   tablespace_    IN VARCHAR2 DEFAULT NULL,
   storage_       IN VARCHAR2 DEFAULT NULL,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Table_Iot');
   Installation_SYS.Create_Table_Iot(table_name_,
                                     columns_,
                                     primary_key_,
                                     tablespace_,
                                     storage_,
                                     show_info_);
END Create_Table_Iot;


PROCEDURE Create_Or_Replace_Table (
   table_name_    IN VARCHAR2,
   columns_       IN ColumnTabType,
   tablespace_    IN VARCHAR2 DEFAULT NULL,
   storage_       IN VARCHAR2 DEFAULT NULL,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Or_Replace_Table');
   Installation_SYS.Create_Or_Replace_Table(table_name_,
                                            columns_,
                                            tablespace_,
                                            storage_,
                                            show_info_);
END Create_Or_Replace_Table;


PROCEDURE Create_Or_Replace_Type (
   type_name_     IN VARCHAR2,
   columns_       IN ColumnTabType,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Or_Replace_Type');
   Installation_SYS.Create_Or_Replace_Type(type_name_,
                                           columns_,
                                           show_info_);
END Create_Or_Replace_Type;


PROCEDURE Create_Or_Replace_Type (
   type_name_     IN VARCHAR2,
   type_table_    IN VARCHAR2,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Or_Replace_Type');
   Installation_SYS.Create_Or_Replace_Type(type_name_,
                                           type_table_,
                                           show_info_);
END Create_Or_Replace_Type;


PROCEDURE Create_Type (
   type_name_     IN VARCHAR2,
   columns_       IN ColumnTabType,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Type');
   Installation_SYS.Create_Type(type_name_,
                                columns_,
                                show_info_);
END Create_Type;


PROCEDURE Create_Type (
type_name_     IN VARCHAR2,
type_table_    IN VARCHAR2,
show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Type');
   Installation_SYS.Create_Type(type_name_,
                                type_table_,
                                show_info_);
END Create_Type;


PROCEDURE Create_Or_Replace_Empty_View (
   view_name_    IN VARCHAR2,
   columns_      IN ColumnViewType,
   lu_           IN VARCHAR2 DEFAULT NULL,
   module_       IN VARCHAR2 DEFAULT NULL,
   server_only_  IN VARCHAR2 DEFAULT NULL,
   show_info_    IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Or_Replace_Empty_View');
   Installation_SYS.Create_Or_Replace_Empty_View(view_name_, columns_, lu_, module_, server_only_, show_info_);
END Create_Or_Replace_Empty_View;


PROCEDURE Create_Temporary_Table (
   table_name_    IN VARCHAR2,
   columns_       IN ColumnTabType,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Temporary_Table');
   Installation_SYS.Create_Temporary_Table(table_name_, columns_, show_info_);
END Create_Temporary_Table;


PROCEDURE Create_Trigger (
   trigger_name_  IN VARCHAR2,
   trigger_type_  IN VARCHAR2,
   dml_event_     IN VARCHAR2,
   columns_       IN ColumnTabType,
   table_name_    IN VARCHAR2,
   condition_     IN VARCHAR2,
   plsql_block_   IN VARCHAR2,
   show_info_     IN BOOLEAN  DEFAULT FALSE ) 
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Create_Trigger');
   Installation_SYS.Create_Trigger(trigger_name_, trigger_type_, dml_event_, columns_, table_name_, condition_, plsql_block_, show_info_);
END Create_Trigger;


FUNCTION Format_Column (
   column_ IN ColRec,
   type_ IN VARCHAR2 DEFAULT 'TABLE' ) RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Format_Column');
   RETURN(Installation_SYS.Format_Column(column_, type_));
END Format_Column;


FUNCTION Format_Columns (
   columns_ IN ColumnTabType,
   type_    IN VARCHAR2 DEFAULT 'TABLE' ) RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Format_Columns');
   RETURN(Installation_SYS.Format_Columns(columns_, type_));
END Format_Columns;


FUNCTION Functionality_Exist (
   functionality_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(Installation_SYS.Functionality_Exist (functionality_));
END Functionality_Exist;


FUNCTION Get_Bind_Length (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN NUMBER
IS
   wrong_data_type EXCEPTION;
   CURSOR get_length IS
   SELECT char_col_decl_length, data_type
   FROM   user_tab_columns
   WHERE  table_name  = upper(table_name_)
   AND    column_name = upper(column_name_);
   bind_length_ NUMBER := 0;
   data_type_   VARCHAR2(30);
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Bind_Length');
   OPEN  get_length;
   FETCH get_length INTO bind_length_, data_type_;
   CLOSE get_length;
   IF (data_type_ != 'VARCHAR2') THEN
      RAISE wrong_data_type;
   END IF;
   RETURN(bind_length_);
EXCEPTION
   WHEN wrong_data_type THEN
      Error_SYS.Appl_General(service_, 'BIND_ERR: Can not use this function because the column ":P1" in table ":P2" is not of data type VARCHAR2.',
                             column_name_, table_name_);
END Get_Bind_Length;


FUNCTION Get_First_Calendar_Date RETURN DATE DETERMINISTIC
IS
BEGIN
   RETURN(first_calendar_gregorian_date_);
/*
IF Get_Database_Calendar = 'GREGORIAN' THEN
   ELSE
      RETURN(first_calendar_persian_date_);
   END IF;
*/
END Get_First_Calendar_Date;


FUNCTION Get_Last_Calendar_Date RETURN DATE DETERMINISTIC
IS
BEGIN
   RETURN(last_calendar_gregorian_date_);
/*
   IF Get_Database_Calendar = 'GREGORIAN' THEN
   ELSE
      RETURN(last_calendar_persian_date_);
   END IF;
*/
END Get_Last_Calendar_Date;


FUNCTION Get_First_Character RETURN VARCHAR2
IS
BEGIN
   IF (Is_Unicode_Character_Set___(Get_Database_Charset)) THEN
      RETURN(Unistr('\0000'));
   ELSE
      RETURN(chr(0));
   END IF;
END Get_First_Character;


FUNCTION Get_Last_Character RETURN VARCHAR2
IS
BEGIN
   IF (Is_Unicode_Character_Set___(Get_Database_Charset)) THEN
      RETURN(Unistr('\FFFF'));
   ELSE
      RETURN(chr(255));
   END IF;
END Get_Last_Character;


FUNCTION Get_Column_Nullable (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Column_Nullable');
   RETURN(Installation_SYS.Get_Column_Nullable (table_name_, column_name_));
END Get_Column_Nullable;


FUNCTION Get_Column_Type (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Column_Type');
   RETURN(Installation_SYS.Get_Column_Type (table_name_, column_name_));
END Get_Column_Type;


FUNCTION Get_Object_Type (
   object_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Object_Type');
   RETURN(Installation_SYS.Get_Object_Type (object_name_));
END Get_Object_Type;


FUNCTION Get_Index_Columns (
   index_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Index_Columns');
   RETURN(Installation_SYS.Get_Index_Columns(index_name_));
END Get_Index_Columns;


FUNCTION Get_Index_Columns (
   table_name_  IN VARCHAR2,
   index_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Index_Columns');
   RETURN(Installation_SYS.Get_Index_Columns(table_name_, index_name_));
END Get_Index_Columns;


FUNCTION Get_Index_Uniqueness (
   table_name_  IN VARCHAR2,
   index_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Index_Uniqueness');
   RETURN(Installation_SYS.Get_Index_Uniqueness(table_name_, index_name_));
END Get_Index_Uniqueness;


FUNCTION Get_Time_Offset RETURN NUMBER
IS
   -- Returns Julian timestamp in seconds
BEGIN
   RETURN(To_Number(To_Char(SYSDATE, 'JSSSSS')));
END Get_Time_Offset;


FUNCTION Index_Exist (
   index_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Index_Exist(index_name_));
END Index_Exist;


FUNCTION Object_Exist (
   object_name_  IN VARCHAR2,
   object_type_  IN VARCHAR2,
   status_       IN VARCHAR2 DEFAULT NULL ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Object_Exist(object_name_, object_type_, status_));
END Object_Exist;


PROCEDURE Remove_All_Cons_And_Idx (
   table_name_ IN VARCHAR2,
   show_info_  IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_All_Cons_And_Idx');
   Installation_SYS.Remove_All_Cons_And_Idx(table_name_,show_info_);
END Remove_All_Cons_And_Idx;


PROCEDURE Remove_Constraints(
   table_name_      IN VARCHAR2,
   constraint_name_ IN VARCHAR2 DEFAULT '%',
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_Constraints');
   Installation_SYS.Remove_Constraints(table_name_, constraint_name_, show_info_);
END Remove_Constraints;


PROCEDURE Remove_Indexes (
   table_name_ IN VARCHAR2,
   index_name_ IN VARCHAR2 DEFAULT '%',
   show_info_  IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_Indexes');
   Installation_SYS.Remove_Indexes(table_name_, index_name_, show_info_);
END Remove_Indexes;


PROCEDURE Remove_Lob_Column (
   table_name_  IN VARCHAR2,
   column_      IN ColRec,
   show_info_   IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_Lob_Column');
   Installation_SYS.Remove_Lob_Column(table_name_, column_, show_info_);
END Remove_Lob_Column;


PROCEDURE Remove_Materialized_View (
   view_name_ IN VARCHAR2,
   show_info_ IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_Materialized_View');
   Installation_SYS.Remove_Materialized_View(view_name_, show_info_);
END Remove_Materialized_View;


PROCEDURE Remove_Materialized_View_Log (
   table_name_ IN VARCHAR2,
   show_info_  IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_Materialized_View_Log');
   Installation_SYS.Remove_Materialized_View_Log(table_name_, show_info_);
END Remove_Materialized_View_Log;


PROCEDURE Remove_Package (
   package_name_ IN VARCHAR2,
   show_info_    IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_Package');
   Installation_SYS.Remove_Package(package_name_, show_info_);
END Remove_Package;


PROCEDURE Remove_Sequence (
   sequence_name_ IN VARCHAR2,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_Sequence');
   Installation_SYS.Remove_Sequence(sequence_name_, show_info_);
END Remove_Sequence;


PROCEDURE Remove_Search_Domain (
   search_domain_ IN VARCHAR2,
   show_info_ IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_Search_Domain');
   Installation_SYS.Remove_Search_Domain(search_domain_, show_info_);
END Remove_Search_Domain;


PROCEDURE Remove_Table (
   table_name_ IN VARCHAR2,
   show_info_  IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_Table');
   Installation_SYS.Remove_Table(table_name_, show_info_);
END Remove_Table;


PROCEDURE Remove_View (
   view_name_ IN VARCHAR2,
   show_info_ IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Remove_View');
   Installation_SYS.Remove_View(view_name_, show_info_);
END Remove_View;


PROCEDURE Rename_Column (
   table_name_       IN VARCHAR2,
   new_column_name_  IN VARCHAR2,
   old_column_name_  IN VARCHAR2,
   show_info_        IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Rename_Column');
   Installation_SYS.Rename_Column(table_name_,
                                  new_column_name_,
                                  old_column_name_,
                                  show_info_);
END Rename_Column;


PROCEDURE Rename_Table (
   source_table_       IN VARCHAR2,
   target_table_       IN VARCHAR2,
   show_info_          IN BOOLEAN  DEFAULT FALSE,
   exception_          IN BOOLEAN  DEFAULT TRUE,
   remove_indexes_     IN BOOLEAN  DEFAULT TRUE,
   remove_constraints_ IN BOOLEAN DEFAULT TRUE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Rename_Table');
   Installation_SYS.Rename_Table (source_table_,
                                  target_table_,
                                  show_info_,
                                  exception_,
                                  remove_indexes_,
                                  remove_constraints_);
END Rename_Table;


PROCEDURE Rename_Constraint (
   table_name_         IN VARCHAR2,
   source_constraint_  IN VARCHAR2,
   target_constraint_  IN VARCHAR2,
   show_info_          IN BOOLEAN  DEFAULT FALSE,
   exception_          IN BOOLEAN  DEFAULT TRUE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Rename_Constraint');
   Installation_SYS.Rename_Constraint(table_name_, source_constraint_, target_constraint_, show_info_, exception_);
END Rename_Constraint;


PROCEDURE Rename_Index (
   source_index_       IN VARCHAR2,
   target_index_       IN VARCHAR2,
   show_info_          IN BOOLEAN  DEFAULT FALSE,
   exception_          IN BOOLEAN  DEFAULT TRUE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Rename_Index');
   Installation_SYS.Rename_Index(source_index_, target_index_, show_info_, exception_);
END Rename_Index;


PROCEDURE Reset_Column (
   column_ IN OUT NOCOPY ColRec )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Reset_Column');
   Installation_SYS.Reset_Column(column_);
END Reset_Column;


PROCEDURE Reset_Column_Table (
   columns_ IN OUT NOCOPY ColumnTabType )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Reset_Column_Table');
   Installation_SYS.Reset_Column_Table (columns_);
END Reset_Column_Table;


FUNCTION Set_Column_Values (
   column_name_   IN     VARCHAR2,
   data_type_     IN     VARCHAR2 DEFAULT NULL,
   nullable_      IN     VARCHAR2 DEFAULT NULL,
   default_value_ IN     VARCHAR2 DEFAULT NULL,
   lob_parameter_ IN     VARCHAR2 DEFAULT NULL,
   keep_default_  IN     VARCHAR2 DEFAULT NULL ) RETURN ColRec
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Set_Column_Values');
   RETURN(Installation_SYS.Set_Column_Values(column_name_, data_type_, nullable_, default_value_, lob_parameter_, keep_default_));
END Set_Column_Values;


PROCEDURE Set_Table_Column (
   columns_ IN OUT NOCOPY ColumnTabType,
   column_  IN     ColRec )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Set_Table_Column');
   Installation_SYS.Set_Table_Column(columns_, column_);
END Set_Table_Column;


PROCEDURE Set_Table_Column (
   columns_       IN OUT NOCOPY ColumnTabType,
   column_name_   IN     VARCHAR2,
   data_type_     IN     VARCHAR2 DEFAULT NULL,
   nullable_      IN     VARCHAR2 DEFAULT NULL,
   default_value_ IN     VARCHAR2 DEFAULT NULL,
   lob_parameter_ IN     VARCHAR2 DEFAULT NULL,
   keep_default_  IN     VARCHAR2 DEFAULT NULL )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Set_Table_Column');
   Installation_SYS.Set_Table_Column(columns_, column_name_, data_type_, nullable_, default_value_, lob_parameter_, keep_default_);
END Set_Table_Column;


FUNCTION Set_View_Column_Values (
   column_name_    IN     VARCHAR2,
   column_source_  IN     VARCHAR2,
   column_comment_ IN     VARCHAR2 DEFAULT NULL ) RETURN ColViewRec
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Set_View_Column_Values');
   RETURN Installation_SYS.Set_View_Column_Values(column_name_, column_source_, column_comment_);
END Set_View_Column_Values;


PROCEDURE Set_View_Column (
   columns_ IN OUT NOCOPY ColumnViewType,
   column_  IN     ColViewRec )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Set_View_Column');
   Installation_SYS.Set_View_Column(columns_, column_);
END Set_View_Column;


PROCEDURE Set_View_Column (
   columns_        IN OUT NOCOPY ColumnViewType,
   column_name_    IN     VARCHAR2,
   column_source_  IN     VARCHAR2,
   column_comment_ IN     VARCHAR2 DEFAULT NULL)
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Set_View_Column');
   Installation_SYS.Set_View_Column(columns_, column_name_, column_source_, column_comment_);
END Set_View_Column;


FUNCTION Table_Exist (
   table_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Table_Exist(table_name_));
END Table_Exist;


FUNCTION View_Exist (
   view_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.View_Exist(view_name_));
END View_Exist;


FUNCTION Package_Exist (
   package_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Package_Exist(package_name_));
END Package_Exist;


FUNCTION Primary_Key_Constraint_Exist (
   table_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Primary_Key_Constraint_Exist(table_name_));
END Primary_Key_Constraint_Exist;


FUNCTION Mtrl_View_Exist (
   mtrl_view_ IN VARCHAR2) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Mtrl_View_Exist(mtrl_view_));
END Mtrl_View_Exist;


FUNCTION Mtrl_View_Log_Exist (
   mtrl_view_log_tbl_ IN VARCHAR2) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Mtrl_View_Log_Exist(mtrl_view_log_tbl_));
END Mtrl_View_Log_Exist;


FUNCTION Method_Exist (
   package_name_ IN VARCHAR2,
   method_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Installation_SYS.Method_Exist(package_name_, method_name_));
END Method_Exist;


PROCEDURE Register_Db_Patch (
   module_       IN VARCHAR2,
   patch_number_ IN NUMBER,
   description_  IN VARCHAR2 DEFAULT NULL )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Register_Db_Patch');
   Installation_SYS.Register_Db_Patch(module_, patch_number_, description_);
END Register_Db_Patch;


FUNCTION Is_Db_Patch_Registered (
   module_       IN VARCHAR2,
   patch_number_ IN NUMBER ) RETURN BOOLEAN
IS
BEGIN
   RETURN Installation_SYS.Is_Db_Patch_Registered(module_, patch_number_);
END Is_Db_Patch_Registered;


PROCEDURE Clear_Db_Patch_Registration (
   module_       IN VARCHAR2,
   patch_number_ IN NUMBER DEFAULT NULL )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Clear_Db_Patch_Registration');
   Installation_SYS.Clear_Db_Patch_Registration(module_, patch_number_);
END Clear_Db_Patch_Registration;


FUNCTION Get_Database_Calendar RETURN VARCHAR2 DETERMINISTIC
IS
BEGIN
   --
   -- Get server instance calendar
   --
   RETURN('GREGORIAN');
   --RETURN(Get_Initialization_Parameter__('NLS_CALENDAR'));
END Get_Database_Calendar;


FUNCTION Get_Database_Host RETURN VARCHAR2
IS
   instance_rec_  sys.v_$instance%ROWTYPE;
BEGIN
   --
   -- Get server host name
   --
   instance_rec_ := Get_Instance_Values___;
   RETURN(instance_rec_.host_name);
END Get_Database_Host;


FUNCTION Get_Database_Sid RETURN VARCHAR2
IS
   instance_rec_  sys.v_$instance%ROWTYPE;
BEGIN
   --
   -- Get server host name
   --
   instance_rec_ := Get_Instance_Values___;
   RETURN(instance_rec_.instance_name);
END Get_Database_Sid;


FUNCTION Get_Database_Charset RETURN VARCHAR2
IS
   charset_ VARCHAR2(30);
   CURSOR get_charset IS
      SELECT value
         FROM  nls_database_parameters
         WHERE parameter = 'NLS_CHARACTERSET';
BEGIN
   --
   -- Get server instance character set
   --
   OPEN  get_charset;
   FETCH get_charset INTO charset_;
   CLOSE get_charset;
   RETURN(charset_);
END Get_Database_Charset;


FUNCTION Get_Database_Name RETURN VARCHAR2
IS
   name_ VARCHAR2(30);
   CURSOR get_name IS
      SELECT name
         FROM sys.v_$database;
BEGIN
   --
   -- Get server instance name
   --
   OPEN  get_name;
   FETCH get_name INTO name_;
   CLOSE get_name;
   RETURN(name_);
END Get_Database_Name;


FUNCTION Get_Database_Version RETURN VARCHAR2
IS
   instance_rec_  sys.v_$instance%ROWTYPE;
BEGIN
   --
   -- Get server instance version
   --
   instance_rec_ := Get_Instance_Values___;
   RETURN(instance_rec_.version);
END Get_Database_Version;


PROCEDURE Get_Database_Properties (
   name_    OUT VARCHAR2,
   version_ OUT VARCHAR2,
   charset_ OUT VARCHAR2 )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Database_Properties');
   --
   -- Get server instance name
   --
   name_ := Get_Database_Name;
   --
   -- Get server instance version
   --
   version_ := Get_Database_Version;
   --
   -- Get server instance character set
   --
   charset_ := Get_Database_Charset;
   --
END Get_Database_Properties;


FUNCTION Get_Formatted_Date (
   date_ IN DATE DEFAULT Sysdate ) RETURN VARCHAR2
IS
BEGIN
   RETURN to_char(date_, Language_Code_API.Get_Nls_Date_Format(Fnd_Session_Api.Get_Language));
END Get_Formatted_Date;


FUNCTION Get_Formatted_Datetime (
   date_ IN DATE DEFAULT Sysdate ) RETURN VARCHAR2
IS
BEGIN
   RETURN to_char(date_, Language_Code_API.Get_Nls_Date_Format(Fnd_Session_Api.Get_Language) || ' ' ||
                         Replace(Language_Code_API.Get_Nls_Time_Format(Fnd_Session_Api.Get_Language),'XFF',''));
END Get_Formatted_Datetime;


FUNCTION Get_Formatted_Time (
   date_ IN DATE DEFAULT Sysdate ) RETURN VARCHAR2
IS
BEGIN
   RETURN to_char(date_, Replace(Language_Code_API.Get_Nls_Time_Format(Fnd_Session_Api.Get_Language),'XFF',''));
END Get_Formatted_Time;


FUNCTION Asciistr (
   value_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(Standard.Asciistr(value_));
END Asciistr;


FUNCTION Asciistr_Xml (
   value_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   return_ VARCHAR2(32767);
   temp_   VARCHAR2(100);
BEGIN
   IF value_ IS NULL THEN
      RETURN(NULL);
   END IF;
   FOR i IN 1..length(value_) LOOP
      temp_ := Substr(value_, i, 1);
      IF ascii(temp_) > 127 THEN
         temp_ := Replace(Database_SYS.Asciistr(temp_), '\', xml_start_)||xml_end_;
      END IF;
      return_ := return_ || temp_;
   END LOOP;
   RETURN(return_);
END Asciistr_Xml;


FUNCTION Unistr (
   value_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(Standard.Unistr(value_));
EXCEPTION
   WHEN OTHERS THEN
      RETURN (value_);
END Unistr;


FUNCTION Unistr_Xml (
   value_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   return_ VARCHAR2(32767);
   from_   BINARY_INTEGER := 1;
   end_    BINARY_INTEGER := 1;
   start_  BINARY_INTEGER := instr(value_, xml_start_, from_);
BEGIN
   IF value_ IS NULL THEN
      RETURN(NULL);
   END IF;
   WHILE start_ > 0 LOOP
      end_    := instr(value_, xml_end_, start_);
      return_ := return_ || Substr(value_, from_, start_ - from_);
      return_ := return_ || Database_SYS.Unistr(Replace(Replace(Substr(value_, start_, end_ - start_), xml_start_, '\'), xml_end_, ''));
      from_   := end_ + 1;
      start_  := instr(value_, xml_start_, from_);
   END LOOP;
   return_ := return_ || Substr(value_, from_);
   RETURN(return_);
END Unistr_Xml;


FUNCTION Db_To_File_Encoding (
   string_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Db_To_File_Encoding');
   IF (Get_File_Encoding = db_encoding_) THEN
      RETURN(string_);
   ELSE
      RETURN(Convert(string_, Get_File_Encoding, db_encoding_));
   END IF;
END Db_To_File_Encoding;


FUNCTION File_To_Db_Encoding (
   string_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'File_To_Db_Encoding');
   IF (Get_File_Encoding = db_encoding_) THEN
      RETURN(string_);
   ELSE
      RETURN(Convert(string_, db_encoding_, Get_File_Encoding));
   END IF;
END File_To_Db_Encoding;


FUNCTION Get_Db_Encoding RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Db_Encoding');
   RETURN(db_encoding_);
END Get_Db_Encoding;


FUNCTION Get_Default_File_Encoding RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Change_Index_Buffer_Pool__');
   RETURN(Fnd_Setting_API.Get_Value('DEFAULT_FILEENCODING'));
END Get_Default_File_Encoding;


FUNCTION Get_File_Encoding RETURN VARCHAR2
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_File_Encoding');
   RETURN(Fnd_Context_SYS.Find_Value('DATABASE_SYS.file_encoding_', Get_Default_File_Encoding));
END Get_File_Encoding;


PROCEDURE Set_Default_File_Encoding
IS
   character_set_ CONSTANT VARCHAR2(100) := Get_Default_File_Encoding;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Set_Default_File_Encoding');
   Set_File_Encoding(character_set_);
END Set_Default_File_Encoding;


PROCEDURE Set_File_Encoding (
   character_set_ IN VARCHAR2 )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Set_File_Encoding');
   Validate_Character_Set___(character_set_);
   Fnd_Context_SYS.Set_Value('DATABASE_SYS.file_encoding_', character_set_);
END Set_File_Encoding;


PROCEDURE Validate_File_Encoding (
   character_set_ IN VARCHAR2 )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Validate_File_Encoding');
   Validate_Character_Set___(character_set_);
END Validate_File_Encoding;


PROCEDURE Comp_Patch_Registration (
   patch_id_     IN NUMBER,
   component_    IN VARCHAR2,
   version_    IN VARCHAR2,
   file_name_    IN VARCHAR2,
   download_    IN DATE,
   description_  IN VARCHAR2 DEFAULT NULL )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Comp_Patch_Registration');
   Component_Patch_API.Comp_Patch_Registration_(patch_id_, upper(component_), version_, file_name_, download_, description_);
END Comp_Patch_Registration;


FUNCTION Comp_Patch_Is_Registered (
   patch_id_     IN NUMBER,
   component_    IN VARCHAR2,
   version_      IN VARCHAR2,
   file_name_    IN VARCHAR2 DEFAULT NULL ) RETURN BOOLEAN
IS
BEGIN
   RETURN Component_Patch_API.Comp_Patch_Is_Registered_(patch_id_, upper(component_), version_, file_name_);
END Comp_Patch_Is_Registered;


PROCEDURE Comp_Patch_Clear_Registration (
   patch_id_     IN NUMBER,
   component_    IN VARCHAR2 DEFAULT '%',
   version_      IN VARCHAR2 DEFAULT '%',
   file_name_    IN VARCHAR2 DEFAULT '%' )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Comp_Patch_Clear_Registration');
   Component_Patch_API.Comp_Patch_Clear_Registration_(patch_id_, upper(component_), version_, file_name_);
END Comp_Patch_Clear_Registration;


PROCEDURE Comp_Patch_Cps_Overwrite (
   component_    IN VARCHAR2,
   version_      IN VARCHAR2,
   patch_id_     IN NUMBER DEFAULT 0 )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Comp_Patch_Cps_Overwrite');
   Component_Patch_API.Comp_Patch_Cps_Overwrite_(upper(component_), version_, patch_id_);
END Comp_Patch_Cps_Overwrite;


FUNCTION Is_Clustered RETURN BOOLEAN
IS
BEGIN
   RETURN dbms_utility.is_cluster_database;
END Is_Clustered;


FUNCTION Get_Compile_Error (
   object_name_  IN VARCHAR2,
   object_type_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   error_ VARCHAR2(32767);

   CURSOR get_error IS
   SELECT line || ' ' || text error
     FROM user_errors
    WHERE name = object_name_
      AND type = object_type_
   ORDER BY sequence;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Compile_Error');
   FOR rec IN get_error LOOP
      error_ := error_ || crlf_ || rec.error;
   END LOOP;
   RETURN(error_);
END Get_Compile_Error;


PROCEDURE Compile_Invalid_Object (
   object_name_  IN VARCHAR2,
   object_type_  IN VARCHAR2 )
IS
   stmt_ VARCHAR2(200);
   compile_error     EXCEPTION;
   PRAGMA            EXCEPTION_INIT(compile_error, -24344);
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Compile_Invalid_Object');
   IF (Object_Exist(object_name_, object_type_, 'INVALID')) THEN
      CASE (object_type_)
      WHEN 'PACKAGE BODY' THEN
            -- Same check is done by Object_Exist, removed for performace reasons
            -- Assert_SYS.Assert_Is_Package(object_name_);
            stmt_ := 'ALTER PACKAGE '|| object_name_ ||' COMPILE BODY';
         WHEN 'JAVA CLASS' THEN
            -- Same check is done by Object_Exist, removed for performace reasons
            -- Assert_SYS.Assert_Is_Java_Class(object_name_);
            stmt_ := 'ALTER '|| object_type_ || ' "' || object_name_ ||'" COMPILE';
         WHEN 'PACKAGE' THEN
            -- Same check is done by Object_Exist, removed for performace reasons
            --Assert_SYS.Assert_Is_User_Object(object_name_ , object_type_);
            stmt_ := 'ALTER '|| object_type_ || ' ' || object_name_ ||' COMPILE';
         WHEN 'VIEW' THEN
            -- Same check is done by Object_Exist, removed for performace reasons
            -- Assert_SYS.Assert_Is_User_Object(object_name_ , object_type_);
            stmt_ := 'ALTER '|| object_type_ || ' ' || object_name_ ||' COMPILE';
         WHEN 'TRIGGER' THEN
            -- Same check is done by Object_Exist, removed for performace reasons
            -- Assert_SYS.Assert_Is_User_Object(object_name_ , object_type_);
            stmt_ := 'ALTER '|| object_type_ || ' ' || object_name_ ||' COMPILE';
         WHEN 'PROCEDURE' THEN
            -- Same check is done by Object_Exist, removed for performace reasons
            -- Assert_SYS.Assert_Is_User_Object(object_name_ , object_type_);
            stmt_ := 'ALTER '|| object_type_ || ' ' || object_name_ ||' COMPILE';
         WHEN 'FUNCTION' THEN
            -- Same check is done by Object_Exist, removed for performace reasons
            -- Assert_SYS.Assert_Is_User_Object(object_name_ , object_type_);
            stmt_ := 'ALTER '|| object_type_ || ' ' || object_name_ ||' COMPILE';
         WHEN 'MATERIALIZED VIEW' THEN
            -- Same check is done by Object_Exist, removed for performace reasons
            -- Assert_SYS.Assert_Is_User_Object(object_name_ , object_type_);
            stmt_ := 'ALTER '|| object_type_ || ' ' || object_name_ ||' COMPILE';
         ELSE
            Error_SYS.Appl_General(service_, 'INVALID_OBJECT_TYPE: Object [:P1] of type [:P2] can''t be compiled.', object_name_, object_type_);
      END CASE;
      Transaction_SYS.Log_Progress_Info(stmt_);
      --@ApproveDynamicStatement(2011-05-30,haarse)
      EXECUTE IMMEDIATE stmt_;
   ELSE
      Error_SYS.Appl_General(service_, 'INVALID_OBJECT: The object [:P1] of type [:P2] doesn''t exist in the database.', object_name_, object_type_);
   END IF;
   Transaction_SYS.Log_Progress_Info('');
EXCEPTION
   WHEN compile_error THEN
      NULL;
END Compile_Invalid_Object;


PROCEDURE Compile_All_Invalid_Objects (
   object_type_ IN VARCHAR2 DEFAULT NULL,
   section_     IN NUMBER DEFAULT NULL,
   sections_    IN NUMBER DEFAULT NULL )
IS
   TYPE invalid_objects_type IS TABLE OF user_objects.object_type%TYPE INDEX BY BINARY_INTEGER;
   inv_obj_         invalid_objects_type;
   i_               BINARY_INTEGER := 0;
   cnt_             NUMBER;
   num_invalids_    NUMBER;
   except_message_  VARCHAR2(200);
   status_          user_objects.status%TYPE;
   module_          dictionary_sys_tab.module%TYPE;
   re_compile_      BOOLEAN := TRUE;
   CURSOR get_object_types IS
      SELECT DISTINCT object_type
      FROM user_objects
      WHERE object_type = Database_SYS.Compile_This_Object_Type(object_type)
      AND object_type = NVL(UPPER(object_type_), object_type)
      ORDER BY DECODE(object_type, 'PACKAGE', 1,
                                   'VIEW', 2,
                                   'PACKAGE BODY', 3,
                                   4 );
   CURSOR get_objects  (obj_type_ VARCHAR2) IS
      SELECT object_name
      FROM  user_objects
      WHERE object_type = obj_type_
      AND   status = 'INVALID'
      ORDER BY object_name;
   CURSOR count_invalids (obj_type_ VARCHAR2) IS
      SELECT count(*)
      FROM  user_objects
      WHERE object_type = obj_type_
      AND   status = 'INVALID';
   CURSOR check_status (obj_type_ VARCHAR2, obj_name_ VARCHAR2) IS
      SELECT status
      FROM  user_objects
      WHERE object_type = obj_type_
      AND   object_name = obj_name_
      AND   status = 'INVALID';
   CURSOR check_module_by_view (obj_name_ VARCHAR2) IS
      SELECT ds.module
      FROM dictionary_sys_tab ds, dictionary_sys_view_tab dsv
      WHERE ds.lu_name = dsv.lu_name
      AND dsv.view_name = obj_name_;
   CURSOR check_module_by_pkg (obj_name_ VARCHAR2) IS
      SELECT ds.module
      FROM dictionary_sys_tab ds, dictionary_sys_package_tab dsp
      WHERE ds.lu_name = dsp.lu_name
      AND (dsp.package_name = obj_name_
      OR   dsp.package_name = SUBSTR(obj_name_, 1, INSTR(obj_name_,'_', -1))||'API');

BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Compile_All_Invalid_Objects');
   FOR obj_rec IN get_object_types LOOP
      i_ := i_ + 1;
      inv_obj_(i_) := obj_rec.object_type;
   END LOOP;
   FOR row_ IN nvl(inv_obj_.FIRST,0) .. nvl(inv_obj_.LAST,-1) LOOP
      cnt_ := 0;
      IF NVL(sections_, 0) > 0
      AND NVL(section_, 0) > 0  
      AND object_type_ IS NOT NULL THEN
         OPEN count_invalids (inv_obj_(row_));
         FETCH count_invalids INTO num_invalids_;
         CLOSE count_invalids;
      END IF;
      FOR rec IN get_objects (inv_obj_(row_)) LOOP
         IF NVL(sections_, 0) > 0
         AND NVL(section_, 0) > 0 
         AND object_type_ IS NOT NULL THEN
            cnt_ := cnt_ + 1;
            IF (cnt_ >= num_invalids_ * (section_ - 1) / sections_)
            AND (cnt_ <= num_invalids_ * (section_) / sections_) THEN
               re_compile_ := TRUE;
            ELSE 
               re_compile_ := FALSE;
            END IF;
         ELSE 
            re_compile_ := TRUE;
         END IF;
         IF re_compile_ THEN
            BEGIN
               Compile_Invalid_Object(rec.object_name, inv_obj_(row_));
            EXCEPTION
               WHEN OTHERS THEN
                  NULL;
            END;
         END IF;
      END LOOP;
   END LOOP;
   IF object_type_ IS NULL THEN
   -- Two times if there still are invalids after the first loop
      FOR row_ IN nvl(inv_obj_.FIRST,0) .. nvl(inv_obj_.LAST,-1) LOOP
         FOR rec IN get_objects (inv_obj_(row_)) LOOP
            except_message_ := inv_obj_(row_)||' '||rec.object_name;
            BEGIN
               Compile_Invalid_Object(rec.object_name, inv_obj_(row_));
            EXCEPTION
               WHEN OTHERS THEN
                  Log_SYS.Fnd_Trace_(Log_SYS.error_, 'Compile error '||except_message_);
            END;
            OPEN check_status (inv_obj_(row_), rec.object_name);
            FETCH check_status INTO status_;
            IF check_status%FOUND THEN
               CLOSE check_status;
               IF inv_obj_(row_) = 'VIEW' THEN
                  OPEN check_module_by_view (rec.object_name);
                  FETCH check_module_by_view INTO module_;
                  IF check_module_by_view%FOUND THEN
                     CLOSE check_module_by_view;
                     except_message_ := except_message_ || ' in component ' || module_;
                  ELSE
                     CLOSE check_module_by_view;
                  END IF;
               END IF;
               IF inv_obj_(row_) IN ('PACKAGE', 'PACKAGE BODY') THEN
                  OPEN check_module_by_pkg (rec.object_name);
                  FETCH check_module_by_pkg INTO module_;
                  IF check_module_by_pkg%FOUND THEN
                     CLOSE check_module_by_pkg;
                     except_message_ := except_message_ || ' in component ' || module_;
                  ELSE
                     CLOSE check_module_by_pkg;
                  END IF;
               END IF;
               Log_SYS.Fnd_Trace_(Log_SYS.error_, 'Compile error exists for '||except_message_);
            ELSE
               CLOSE check_status;
            END IF;
         END LOOP;
      END LOOP;
      Log_SYS.Fnd_Trace_(Log_SYS.error_, 'INVALID OBJECTS AFTER RECOMPILE');
      Log_SYS.Fnd_Trace_(Log_SYS.error_, '-------------------------------');
      FOR row_ IN nvl(inv_obj_.FIRST,0) .. nvl(inv_obj_.LAST,-1) LOOP
         OPEN count_invalids (inv_obj_(row_));
         FETCH count_invalids INTO num_invalids_;
         CLOSE count_invalids;
         Log_SYS.Fnd_Trace_(Log_SYS.error_, RPAD(inv_obj_(row_)||':', 25)||LPAD(num_invalids_, 5));
      END LOOP;
      Log_SYS.Fnd_Trace_(Log_SYS.error_, '-------------------------------');
   END IF;
   Transaction_SYS.Log_Progress_Info('');
END Compile_All_Invalid_Objects;


FUNCTION Compile_This_Object_Type (
   object_type_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF object_type_ IN ('PACKAGE BODY', 'JAVA CLASS', 'PACKAGE', 'VIEW', 'TRIGGER', 'PROCEDURE', 'FUNCTION', 'MATERIALIZED VIEW') THEN
      RETURN object_type_;
   ELSE
      RETURN NULL;
   END IF;
END Compile_This_Object_Type;


FUNCTION Count_Nodes RETURN NUMBER
IS
   nodes_ NUMBER;
   CURSOR get_number_of_nodes IS
      SELECT COUNT(*)
         FROM GV$INSTANCE;
BEGIN
   OPEN  get_number_of_nodes;
      FETCH get_number_of_nodes INTO nodes_;
   CLOSE get_number_of_nodes;
   RETURN nodes_;
END Count_Nodes;


FUNCTION Get_Platform_Id RETURN NUMBER
IS
   platform_id_ NUMBER;
   CURSOR get_id IS
      SELECT PLATFORM_ID
         FROM V$DATABASE;
BEGIN
   OPEN  get_id;
      FETCH get_id INTO platform_id_;
   CLOSE get_id;
   RETURN platform_id_;
END Get_Platform_Id;


FUNCTION Get_Db_Os RETURN VARCHAR2
IS
   db_os_      VARCHAR2(120);
BEGIN
   db_os_ := CASE Get_Platform_Id
             WHEN 1 THEN 'Solaris[tm] OE (32-bit)'
             WHEN 2 THEN 'Solaris[tm] OE (64-bit)'
             WHEN 3 THEN 'HP-UX (64-bit)'
             WHEN 4 THEN 'HP-UX (64-bit)'
             WHEN 5 THEN 'HP Tru64 UNIX'
             WHEN 6 THEN 'AIX-Based Systems (64-bit)'
             WHEN 7 THEN 'Microsoft Windows NT'
             WHEN 8 THEN 'Linux IA (32-bit)'
             WHEN 9 THEN 'Linux IA (64-bit)'
             ELSE        'Other'
        END;
   RETURN db_os_;
END Get_Db_Os;


FUNCTION Get_Db_Hardware RETURN VARCHAR2
IS
   db_hw_         VARCHAR2(120);
BEGIN
   db_hw_ := CASE Get_Platform_Id()
             WHEN 1 THEN 'SPARC'
             WHEN 2 THEN 'SPARC'
             WHEN 3 THEN 'PA RISC'
             WHEN 4 THEN 'IA RISC'
             WHEN 5 THEN 'DEC Alpha'
             WHEN 6 THEN 'Power PC'
             WHEN 7 THEN 'Intel or AMD X86'
             WHEN 8 THEN 'Intel or AMD X86'
             WHEN 9 THEN 'IA64'
             ELSE        'Other'
             END;

   RETURN db_hw_;
END Get_Db_Hardware;


FUNCTION Get_Init_Ora_Parameter (
   parameter_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN(Get_Init_Ora_Parameter___(parameter_));
END Get_Init_Ora_Parameter;


FUNCTION Is_Unicode_Character_Set RETURN BOOLEAN
IS
BEGIN
   RETURN  Is_Unicode_Character_Set___(Get_Database_Charset);
END Is_Unicode_Character_Set;


FUNCTION Get_Lob_Freepools (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Lob_Freepools');
   RETURN (Installation_SYS.Get_Lob_Freepools(table_name_, column_name_));
END Get_Lob_Freepools;


FUNCTION Get_Chunk_Lob_Size (
   table_name_   IN VARCHAR2,
   column_name_  IN VARCHAR2 ) RETURN NUMBER
IS
   chunk_size_   NUMBER;
   CURSOR get_chunk_size IS 
      SELECT nvl(round(decode(l.in_row, 'YES', 0, 1)*t.num_rows * l.chunk/1024/1024, 2),0)
        FROM user_lobs l, user_tables t
       WHERE l.table_name = t.table_name
         AND l.table_name = table_name_
         AND l.column_name = column_name_;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Chunk_Lob_Size');
   OPEN  get_chunk_size;
   FETCH get_chunk_size INTO chunk_size_;
   CLOSE get_chunk_size;
   RETURN chunk_size_;
END Get_Chunk_Lob_Size;


FUNCTION Get_Physical_Lob_Size (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN NUMBER
IS
   stmt_       VARCHAR2(1000) := 'SELECT Round(Nvl(Sum(Nvl(Dbms_Lob.Getlength(' || column_name_ || '),0)),0)/1024/1024,2) FROM ' || table_name_;
   lob_size_   NUMBER;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Physical_Lob_Size');
   Assert_SYS.Assert_Is_Table_Column(table_name_, column_name_);
   --@ApproveDynamicStatement(2010-03-19,haarse)
   EXECUTE IMMEDIATE stmt_ INTO lob_size_;
   RETURN (lob_size_);
END Get_Physical_Lob_Size;


FUNCTION Get_Allocated_Lob_Size (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR get_length IS 
   SELECT allocated_lob_size
     FROM oracle_lob_extents
    WHERE table_name = table_name_
    and column_name = column_name_;
     
   lob_size_   NUMBER;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Get_Allocated_Lob_Size');
   OPEN  get_length;
   FETCH get_length INTO lob_size_;
   CLOSE get_length;
   RETURN (lob_size_);
END Get_Allocated_Lob_Size;


PROCEDURE Change_All_Clob_Row_Movement (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2, 
   tablespace_  IN VARCHAR2 DEFAULT 'IFSAPP_LOB',
   show_info_   IN BOOLEAN  DEFAULT TRUE )
IS
   CURSOR get_clobs IS 
  SELECT l.table_name, l.column_name
    FROM user_lobs l, user_tab_columns c
   WHERE l.table_name = c.table_name
     AND l.column_name = c.column_name
     AND l.in_row = 'NO'
     AND c.data_type = 'CLOB';
  
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Change_All_Clob_Row_Movement');
   --
   FOR rec IN get_clobs LOOP
      Change_Lob_Row_Movement(rec.table_name, rec.column_name, tablespace_, show_info_);
   END LOOP;
END Change_All_Clob_Row_Movement;


PROCEDURE Change_Lob_Row_Movement (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2, 
   tablespace_  IN VARCHAR2 DEFAULT 'IFSAPP_LOB',
   show_info_   IN BOOLEAN  DEFAULT TRUE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Change_Lob_Row_Movement');
   --
   -- Note! This command locks the table, possibly a long time for a large table, meaning endusers can not use the table during the operation
   --       Enable row movement must be enabled on the table in order to make the shrink command available
   --       May lead to unusable Search Domain indexes
   IF (Has_Domain_Index___(table_name_)) THEN 
      Log_SYS.Fnd_Trace_(Log_SYS.debug_, 'Table '||table_name_||' has a domain index and will not be moved.');
   ELSE
      Installation_SYS.Change_Lob_Row_Movement(table_name_, column_name_, tablespace_, show_info_);
      Rebuild_Unusable_Indexes___(table_name_, show_info_);
   END IF;
END Change_Lob_Row_Movement;


PROCEDURE Move_Lob_Segment (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2, 
   tablespace_  IN VARCHAR2 DEFAULT 'IFSAPP_LOB',
   show_info_   IN BOOLEAN  DEFAULT TRUE )
IS
   changed_ BOOLEAN := FALSE;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Move_Lob_Segment');
   --
   -- Note! This command locks the table, possibly a long time for a large table, meaning endusers can not use the table during the operation
   --       Enable row movement must be enabled on the table in order to make the shrink command available
   --       May lead to unusable Search Domain indexes
   IF (Has_Domain_Index___(table_name_)) THEN 
      Log_SYS.Fnd_Trace_(Log_SYS.debug_, 'Table '||table_name_||' has a domain index and will not be moved.');
   ELSE
      IF NOT Database_SYS.Is_Rowmovement_Enabled(table_name_) THEN 
         Installation_SYS.Alter_Table_Rowmovement(table_name_, TRUE, show_info_);
         changed_ := TRUE;
      END IF;
      Installation_SYS.Move_Lob_Segment(table_name_, column_name_, tablespace_, show_info_);
      Rebuild_Unusable_Indexes___(table_name_, show_info_);
      IF changed_ THEN
         Installation_SYS.Alter_Table_Rowmovement(table_name_, TRUE, show_info_);
      END IF;         
  END IF;
END Move_Lob_Segment;


PROCEDURE Move_Lob_Tablespace(
   temp_tablespace_ IN VARCHAR2 )
IS

   CURSOR get_lobs IS
   SELECT table_name,
          column_name,
          allocated_lob_size,
          secure_file,
          tablespace
     FROM oracle_lob_extents
    WHERE table_name NOT LIKE 'DR$%' -- Dont include Oracle Text objects
      ORDER BY table_name, column_name;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Move_Lob_Tablespace');
   FOR rec IN get_lobs LOOP
      BEGIN
         --
         -- Possibly could the following command make more space available for shrinking (this has never been proven by HAARSE).
         -- "alter table [table_name] modify lob ([lob_column_name]) (freepools X);" where x is the number of freepools seen in USER_LOBS
         --
         -- Note! This command locks the table, possibly a long time for a large table, meaning endusers can not use the table during the operation
         --       Enable row movement must be enabled on the table in order to make the shrink command available
         --
         Installation_SYS.Alter_Lob_Freepools(rec.table_name, rec.column_name, TRUE);
         Database_SYS.Move_Lob_Segment(rec.table_name, rec.column_name, temp_tablespace_, TRUE);
         Log_SYS.Fnd_Trace_(Log_SYS.info_, '   Move the lob '|| rec.column_name || ' in table '|| rec.table_name || ' from ' || rec.tablespace || ' to ' || temp_tablespace_ || '.');
         Database_SYS.Move_Lob_Segment(rec.table_name, rec.column_name, rec.tablespace, TRUE);
         Log_SYS.Fnd_Trace_(Log_SYS.info_, '   Move the lob '|| rec.column_name || ' in table '|| rec.table_name || ' from ' || temp_tablespace_ || ' back to ' || rec.tablespace || '.');
         Transaction_SYS.Log_Progress_Info(' ');
         Transaction_SYS.Log_Status_Info('   Move the lob '|| rec.column_name || ' in table '|| rec.table_name || ' has finished.', 'INFO');
      EXCEPTION
         WHEN OTHERS THEN
            Log_SYS.Fnd_Trace_(Log_SYS.info_, Substr('Error during move of LOB segment ' || rec.column_name || ' in table ' ||rec.table_name || ' failed, due to Oracle error ' || SQLERRM || '.',1,2000) || '.');
            Transaction_SYS.Log_Status_Info(Substr('Error during move of LOB segment ' || rec.column_name || ' in table ' ||rec.table_name || ' failed, due to Oracle error ' || SQLERRM || '.',1,2000) || '.', 'WARNING');
            RAISE;
      END;
   END LOOP;
END Move_Lob_Tablespace;


PROCEDURE Shrink_Lob_Segments(
   allocated_lob_size_ IN NUMBER DEFAULT 1000,
   reclaimed_size_     IN NUMBER DEFAULT 100)
IS
   physical_lob_size_   NUMBER;
   chunk_size_          NUMBER;

   CURSOR get_lobs IS
   SELECT table_name,
          column_name,
          allocated_lob_size,
          secure_file,
          tablespace
     FROM oracle_lob_extents
    WHERE table_name NOT LIKE 'DR$%' -- Dont include Oracle Text objects
      AND table_name != 'TRANSACTION_SYS_LOCAL_TAB'
      AND allocated_lob_size > allocated_lob_size_
      ORDER BY table_name, column_name;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Shrink_Lob_Segments');
   FOR rec IN get_lobs LOOP
         -- Checked for assertion before call Installation_SYS
         Assert_SYS.Assert_Is_Table_Column(rec.table_name, rec.column_name);
         physical_lob_size_ := Get_Physical_Lob_Size(rec.table_name, rec.column_name);
         chunk_size_        := Get_Chunk_Lob_Size(rec.table_name, rec.column_name);
         IF  ( rec.allocated_lob_size - Greatest(chunk_size_, physical_lob_size_) >= reclaimed_size_ ) THEN
            Log_SYS.Fnd_Trace_(Log_SYS.info_, 'Shrinking the lob segment ' || rec.column_name || ' in table '|| rec.table_name || '.');
            Log_SYS.Fnd_Trace_(Log_SYS.info_, '   Allocated Lob size: ' || to_char(rec.allocated_lob_size) || ' Mb Physical Lob Size: ' || physical_lob_size_ || 'Mb.');
            Transaction_SYS.Log_Progress_Info('Trying to shrink the lob '|| rec.column_name || ' in table '|| rec.table_name || '.');
            Transaction_SYS.Log_Status_Info('Trying to shrink the lob '|| rec.column_name || ' in table '|| rec.table_name || '. ' || Database_SYS.Get_Formatted_Datetime(SYSDATE), 'INFO');
            Transaction_SYS.Log_Status_Info('   Allocated Lob size: ' || to_char(rec.allocated_lob_size) || ' Mb Physical Lob Size: ' || physical_lob_size_ || ' Mb.', 'INFO');
            IF (rec.secure_file = 'NO') THEN -- Basicdata file LOBs
               BEGIN
                  --
                  -- Possibly could the following command make more space available for shrinking (this has never been proven by HAARSE).
                  -- "alter table [table_name] modify lob ([lob_column_name]) (freepools X);" where x is the number of freepools seen in USER_LOBS
                  --
                  -- Note! This command locks the table, possibly a long time for a large table, meaning endusers can not use the table during the operation
                  --       Enable row movement must be enabled on the table in order to make the shrink command available
                  --
                  Installation_SYS.Alter_Lob_Freepools(rec.table_name, rec.column_name, TRUE);
                  Installation_SYS.Shrink_Lob_Segment(rec.table_name, rec.column_name, TRUE);
                  Transaction_SYS.Log_Progress_Info(' ');
                  Transaction_SYS.Log_Status_Info('   Trying to shrink the lob '|| rec.column_name || ' in table '|| rec.table_name || ' has finished.', 'INFO');
               EXCEPTION
                  WHEN OTHERS THEN
                     Transaction_SYS.Log_Status_Info(Substr('Shrinking of lob segment ' || rec.column_name || ' in table ' ||rec.table_name || ' failed, due to Oracle error ' || SQLERRM || '.',1,2000) || '.', 'WARNING');
                     Rebuild_Unusable_Indexes___(rec.table_name, TRUE);
               END;
            ELSE -- Securefile LOBs
               BEGIN
                  --
                  -- Possibly could the following command make more space available for shrinking (this has never been proven by HAARSE).
                  -- "alter table [table_name] modify lob ([lob_column_name]) (freepools X);" where x is the number of freepools seen in USER_LOBS
                  --
                  -- Note! This command locks the table, possibly a long time for a large table, meaning endusers can not use the table during the operation
                  --       Enable row movement must be enabled on the table in order to make the shrink command available
                  --
                  Installation_SYS.Alter_Lob_Freepools(rec.table_name, rec.column_name, TRUE);
                  Database_SYS.Move_Lob_Segment(rec.table_name, rec.column_name, rec.tablespace, TRUE);
                  Log_SYS.Fnd_Trace_(Log_SYS.info_, '   Trying to shrink the lob '|| rec.column_name || ' in table '|| rec.table_name || ' has finished.');
                  Transaction_SYS.Log_Progress_Info(' ');
                  Transaction_SYS.Log_Status_Info('   Trying to shrink the lob '|| rec.column_name || ' in table '|| rec.table_name || ' has finished.', 'INFO');
               EXCEPTION
                  WHEN OTHERS THEN
                     Log_SYS.Fnd_Trace_(Log_SYS.info_, Substr('Shrinking of lob segment ' || rec.column_name || ' in table ' ||rec.table_name || ' failed, due to Oracle error ' || SQLERRM || '.',1,2000) || '.');
                     Transaction_SYS.Log_Status_Info(Substr('Shrinking of lob segment ' || rec.column_name || ' in table ' ||rec.table_name || ' failed, due to Oracle error ' || SQLERRM || '.',1,2000) || '.', 'WARNING');
                     Rebuild_Unusable_Indexes___(rec.table_name, TRUE);
               END;
            END IF;
         END IF;
   END LOOP;
END Shrink_Lob_Segments;


PROCEDURE Move_Object (
   object_name_ IN VARCHAR2,    
   tablespace_  IN VARCHAR2 DEFAULT NULL,
   show_info_  IN BOOLEAN  DEFAULT FALSE)   
IS
   
BEGIN  
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Move_Object');
   Installation_SYS.Move_Object(object_name_, tablespace_, show_info_);
END Move_Object;   


PROCEDURE Grant_All_Objects_Ial (
   ial_owner_  IN VARCHAR2 )
IS
   stmt_    VARCHAR2(2000);
   setting_ VARCHAR2(30);
   dummy_   NUMBER;

   CURSOR get_objs IS
      SELECT object_name,
             decode(object_type,
                    'VIEW',    'SELECT',
                    'TABLE',   'SELECT',
                    'PACKAGE', 'EXECUTE', NULL) grant_option
      FROM user_objects
      WHERE  object_type IN ('VIEW', 'TABLE', 'PACKAGE')
      AND object_name NOT LIKE 'SYS_IOT%'
         MINUS
      SELECT table_name object_name, privilege
      FROM user_tab_privs_made
      WHERE privilege IN ('SELECT','EXECUTE')
      AND grantee = ial_owner_;

   CURSOR check_user IS
      SELECT 1
      FROM sys.all_users
      WHERE username = upper(ial_owner_);

   CURSOR get_setting IS
      SELECT upper(value)
      FROM fnd_setting_tab
      WHERE parameter = 'IAL_USER';

BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Grant_All_Objects_Ial');
   -- Check that the user is a valid Oracle user
   OPEN check_user;
   FETCH check_user INTO dummy_;
   IF check_user%NOTFOUND THEN
      CLOSE check_user;
      Log_SYS.Fnd_Trace_(Log_SYS.error_, 'ERROR: ial_owner_ is not a user, execution failed!');
   ELSE
      CLOSE check_user;
      -- Trace if F1 settings are incorrect
      -- Method Fnd_Setting_API.Get_Value can not be used,
      -- it would lock this package from being granted...
      OPEN get_setting;
      FETCH get_setting INTO setting_;
      CLOSE get_setting;
      IF setting_ IS NULL OR setting_ <> upper(ial_owner_)  THEN
         Log_SYS.Fnd_Trace_(Log_SYS.error_, 'INFO: '||ial_owner_||' is not configured to be the IAL user, check your configuration before proceeding!');
      ELSE
         -- Proceed with the granting
         FOR rec IN get_objs LOOP
            BEGIN
               Assert_SYS.Assert_Is_In_Whitelist(rec.grant_option, 'SELECT,EXECUTE');
               Assert_SYS.Assert_Is_User_Object(rec.object_name);
               Assert_SYS.Assert_Is_User(ial_owner_);
               stmt_ := 'GRANT '||rec.grant_option||' ON '||rec.object_name||' TO '||ial_owner_||' WITH GRANT OPTION';
               --@ApproveDynamicStatement(2011-05-30,haarse)
               EXECUTE IMMEDIATE stmt_;
            EXCEPTION
               WHEN OTHERS THEN
                  Log_SYS.Fnd_Trace_(Log_SYS.error_, 'INFO: The following statement failed ''' || stmt_ || ''';');
            END;
         END LOOP;
         Security_SYS.Grant_Role('FND_IAL_ADMIN', ial_owner_);
      END IF;
   END IF;
END Grant_All_Objects_Ial;


PROCEDURE Grant_All (
   role_  IN VARCHAR2 )
IS
   CURSOR all_pres_objects IS
      SELECT po_id
        FROM pres_object_tab
       WHERE module NOT IN ('FNDADM', 'FNDBAS', 'FNDWEB', 'FNDCOB');

   CURSOR all_permission_sets IS
      SELECT role
        FROM fnd_role_tab
       WHERE role <> role_
         AND role NOT LIKE 'FND%'
         AND role NOT LIKE 'IFS%';
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Grant_All');
   IF (Fnd_Role_API.Get_Fnd_Role_Type(role_) IS NOT NULL) THEN
      Log_SYS.Fnd_Trace_(Log_SYS.info_, 'Grant Presentation Objects to ' || role_);
      BEGIN
         FOR po IN all_pres_objects LOOP
            BEGIN
               IF (Pres_Object_Util_API.Get_Grant_Info(po.po_id, role_) != 'GRANTED') THEN
                  Pres_Object_Util_API.Grant_Pres_Object( po.po_id, role_);
               END IF;
            EXCEPTION
               WHEN OTHERS THEN
                  Log_SYS.Fnd_Trace_(Log_SYS.error_, 'Error when trying to grant Po Id: '||po.po_id);
            END;
         END LOOP;
      END;
      --
      Grant_All_Hud_Pres_Objects___(role_);
      --
      Log_SYS.Fnd_Trace_(Log_SYS.info_, 'Grant Permission Sets to ' || role_);
      BEGIN
         FOR ps IN all_permission_sets LOOP
            BEGIN
               Security_SYS.Grant_Role( ps.role, role_);
            EXCEPTION
               WHEN OTHERS THEN
                  Log_SYS.Fnd_Trace_(Log_SYS.error_, 'Error when trying to grant Role: '||ps.role);
            END;
         END LOOP;
      END;
      Log_SYS.Fnd_Trace_(Log_SYS.info_, 'grant role FND_ENDUSER to ' || role_);
      Security_SYS.Grant_Role( 'FND_ENDUSER', role_);
   ELSE
      Log_SYS.Fnd_Trace_(Log_SYS.error_, 'Role: ' || role_ || ' does not exist');
   END IF;
   Security_SYS.Refresh_Active_List__(1);
END Grant_All;


PROCEDURE Validate_Password (
   password_ IN VARCHAR2 )
IS
BEGIN
   Assert_SYS.Assert_Is_Valid_Password(password_);
END Validate_Password;


PROCEDURE Register_Cleanup_Table (
   table_name_ IN VARCHAR2,
   column_name_  IN VARCHAR2,
   age_ IN NUMBER )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Register_Cleanup_Table');
   Security_SYS.Has_System_Privilege('DEFINE SQL', Fnd_Session_API.Get_Fnd_User);
   INSERT INTO cleanup_temporary_data_tab
   (table_name, column_name, age, user_name, time_stamp)
   VALUES
   (UPPER(table_name_), UPPER(column_name_), age_, Fnd_Session_API.Get_Fnd_User, SYSDATE);
EXCEPTION
   WHEN dup_val_on_index THEN
      UPDATE cleanup_temporary_data_tab
      SET column_name = UPPER(column_name_),
      age = age_,
      user_name = Fnd_Session_API.Get_Fnd_User,
      time_stamp = SYSDATE
      WHERE table_name = UPPER(table_name_);
END Register_Cleanup_Table;


PROCEDURE Installation_Summary
IS
   found_ BOOLEAN := FALSE;
   CURSOR get_invalids IS
      SELECT object_type, COUNT(*) cnt
      FROM user_objects
      WHERE status = 'INVALID'
      GROUP BY object_type
      ORDER BY DECODE(object_type, 'PACKAGE', 1,
                                   'VIEW', 2,
                                   'PACKAGE BODY', 3,
                                   4 );
   CURSOR get_changed_po IS
      SELECT 'New modules' change_info, COUNT(*) cnt
      FROM module_tab 
      WHERE module IN
      (SELECT DISTINCT module
       FROM (SELECT module FROM pres_object_tab
             MINUS
             SELECT module FROM pres_object_snap_tab))
      UNION
      SELECT 'New PO for existing modules' change_info, COUNT(*) cnt
      FROM (SELECT po_id, module, pres_object_type FROM pres_object_tab
            MINUS
            SELECT po_id, module, pres_object_type FROM  pres_object_snap_tab) diff
      WHERE diff.module NOT IN 
      (SELECT DISTINCT module 
       FROM(SELECT module 
            FROM pres_object_tab
            MINUS
            SELECT module 
            FROM pres_object_snap_tab))
      UNION
      SELECT 'New objects for existing PO' change_info, COUNT(*) cnt
      FROM (SELECT po.module, po.pres_object_type, pos.po_id, pos.sec_object, pos.sec_object_type 
            FROM pres_object_security_tab pos, pres_object_tab po
            WHERE pos.po_id = po.po_id
            MINUS
            SELECT po.module, po.pres_object_type, pos.po_id, pos.sec_object, pos.sec_object_type  
            FROM pres_object_security_snap_tab pos, pres_object_tab po
            WHERE pos.po_id = po.po_id)
      WHERE (module,po_id) NOT IN
            (SELECT module, po_id
             FROM  pres_object_tab
             MINUS
             SELECT module,po_id
             FROM  pres_object_snap_tab)
      UNION
      SELECT 'Removed modules' change_info, COUNT(*) cnt
      FROM module_tab 
      WHERE module IN
      (SELECT DISTINCT module
       FROM (SELECT module
             FROM pres_object_snap_tab
             MINUS
             SELECT module FROM pres_object_tab))
      UNION
      SELECT 'Removed PO' change_info, COUNT(*) cnt
      FROM (SELECT po_id, module, pres_object_type
            FROM pres_object_snap_tab
            MINUS
            SELECT po_id, module, pres_object_type
            FROM pres_object_tab) diff;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Installation_Summary');
   Log_SYS.Fnd_Trace_(Log_SYS.error_, ' ');
   Log_SYS.Fnd_Trace_(Log_SYS.error_, ' ');
   Log_SYS.Fnd_Trace_(Log_SYS.error_, '-----------------------------------');
   Log_SYS.Fnd_Trace_(Log_SYS.error_, 'D E P L O Y M E N T   S U M M A R Y');
   Log_SYS.Fnd_Trace_(Log_SYS.error_, '-----------------------------------');
   Log_SYS.Fnd_Trace_(Log_SYS.error_, ' ');
   Log_SYS.Fnd_Trace_(Log_SYS.error_, 'INVALID OBJECTS');
   Log_SYS.Fnd_Trace_(Log_SYS.error_, '---------------');
   FOR row_inv IN get_invalids LOOP
      Log_SYS.Fnd_Trace_(Log_SYS.error_, RPAD(row_inv.object_type||':', 30)||LPAD(row_inv.cnt, 5));
      found_ := TRUE;
   END LOOP;
   IF NOT found_ THEN
      Log_SYS.Fnd_Trace_(Log_SYS.error_, RPAD('INVALID OBJECTS:', 30)||LPAD('0', 5));
   END IF;
   found_ := FALSE;
   Log_SYS.Fnd_Trace_(Log_SYS.error_, ' ');
   Log_SYS.Fnd_Trace_(Log_SYS.error_, 'PRESENTATION OBJECTS');
   Log_SYS.Fnd_Trace_(Log_SYS.error_, '--------------------');
   FOR row_po IN get_changed_po LOOP
      Log_SYS.Fnd_Trace_(Log_SYS.error_, RPAD(row_po.change_info||':', 30)||LPAD(row_po.cnt, 5));
      found_ := TRUE;
   END LOOP;
   IF NOT found_ THEN
      Log_SYS.Fnd_Trace_(Log_SYS.error_, RPAD('PRESENTATION OBJECTS:', 30)||LPAD('0', 5));
   END IF;
   found_ := FALSE;
   Log_SYS.Fnd_Trace_(Log_SYS.error_, ' ');
END Installation_Summary;


FUNCTION Is_Rowkey_Enabled_Table (
   table_name_   IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (NOT Database_SYS.Column_Exist(table_name_, 'ROWKEY')) THEN
      RETURN(Fnd_Boolean_API.DB_FALSE);
   END IF;
   CASE Installation_SYS.Get_Column_Nullable(table_name_, 'ROWKEY')
   WHEN NULL THEN
      RETURN(NULL);
   WHEN 'N' THEN
      RETURN(Fnd_Boolean_API.DB_TRUE);
   WHEN 'Y' THEN
      RETURN(Fnd_Boolean_API.DB_FALSE);
   ELSE
      RETURN(NULL);
   END CASE;
END Is_Rowkey_Enabled_Table;


PROCEDURE Alter_Tablespace_ (
   text_        OUT CLOB,
   show_info_   IN BOOLEAN  DEFAULT TRUE )
IS
   block_size_ NUMBER;
   
   CURSOR get_blocksize IS
      SELECT value
      FROM   v$parameter
      WHERE  name = 'db_block_size';

   CURSOR get_alter_cmd IS 
   SELECT 'ALTER DATABASE DATAFILE '''||file_name||''' RESIZE ' || ceil( (nvl(hwm,1)*block_size_)/1024/1024 ) || 'M;' command,
          ceil( blocks*block_size_/1024/1024) - ceil( (nvl(hwm,1)*block_size_)/1024/1024 ) savings,
          file_name
   FROM dba_data_files a, ( SELECT file_id, max(block_id+blocks-1) hwm
                            FROM dba_extents
                            GROUP by file_id ) b
   WHERE a.file_id = b.file_id(+)
   AND ceil( blocks*block_size_/1024/1024) - ceil( (nvl(hwm,1)*block_size_)/1024/1024 ) > 0;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Alter_Tablespace_');
   OPEN  get_blocksize;
   FETCH get_blocksize INTO block_size_;
   CLOSE get_blocksize;
   --
   FOR rec IN get_alter_cmd LOOP    
      Log_SYS.Fnd_Trace_(Log_SYS.info_,'-- Savings ' || rec.savings || 'Mb for file ' || rec.file_name || '.');
      Log_SYS.Fnd_Trace_(Log_SYS.info_, rec.command);
      text_ := text_ || '-- Savings ' || rec.savings || 'Mb for file ' || rec.file_name || '.' || chr(10);
      text_ := text_ || rec.command || chr(10);
   END LOOP;
END Alter_Tablespace_;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PROTECTED METHODS --------------------------
-----------------------------------------------------------------------------

PROCEDURE Init_All_Packages_ (
   dummy_ IN NUMBER )
IS
   stmt_   VARCHAR2(100);
   CURSOR all_init_pkgs IS
      SELECT name
      FROM  user_source
      WHERE type = 'PACKAGE'
      AND   text LIKE '%PROCEDURE%Init;%';
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Init_All_Packages_');
   FOR pkg IN all_init_pkgs LOOP
      BEGIN
         Assert_SYS.Assert_Is_Package(pkg.name);
         stmt_ := 'BEGIN '||pkg.name||'.Init; END;';
         --@ApproveDynamicStatement(2006-01-05,utgulk)
         EXECUTE IMMEDIATE stmt_;
      EXCEPTION
         WHEN OTHERS THEN
            -- If any problems, do not raise, but just printout!
            Log_SYS.Fnd_Trace_(Log_SYS.error_, 'Error in statement: '||stmt_);
      END;
   END LOOP;
END Init_All_Packages_;


FUNCTION First_Calendar_Date_ RETURN DATE DETERMINISTIC
IS
BEGIN
   RETURN(Get_First_Calendar_Date);
END First_Calendar_Date_;


FUNCTION Last_Calendar_Date_ RETURN DATE DETERMINISTIC
IS
BEGIN
   RETURN(Get_Last_Calendar_Date);
END Last_Calendar_Date_;


PROCEDURE Compile_Schema_ (
   schema_     IN VARCHAR2,
   do_compile_ IN VARCHAR2 DEFAULT 'Y' )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Compile_Schema_');
   IF UPPER(SUBSTR(do_compile_, 1, 1)) = 'Y' THEN
      --@ApproveDynamicStatement(2014-12-19,mabose)
      EXECUTE IMMEDIATE 'BEGIN Dbms_Utility.Compile_Schema(:schema_); END;' USING schema_;
   END IF;
END Compile_Schema_;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PRIVATE METHODS ----------------------------
-----------------------------------------------------------------------------

PROCEDURE Change_Index_Buffer_Pool__ (
   index_name_  IN VARCHAR2,
   buffer_pool_ IN VARCHAR2 DEFAULT 'DEFAULT' )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Change_Index_Buffer_Pool__');
   Assert_SYS.Assert_Is_Index(index_name_);
   --@ApproveDynamicStatement(2006-01-05,utgulk)
   EXECUTE IMMEDIATE 'ALTER INDEX "'||index_name_||'" STORAGE ( BUFFER_POOL '||buffer_pool_||')';
END Change_Index_Buffer_Pool__;


PROCEDURE Change_Table_Buffer_Pool__ (
   table_name_  IN VARCHAR2,
   buffer_pool_ IN VARCHAR2 DEFAULT 'DEFAULT' )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Change_Table_Buffer_Pool__');
   Assert_SYS.Assert_Is_Table(table_name_);
   --@ApproveDynamicStatement(2006-01-05,utgulk)
   EXECUTE IMMEDIATE 'ALTER TABLE "'||table_name_||'" STORAGE ( BUFFER_POOL '||buffer_pool_||')';
END Change_Table_Buffer_Pool__;


PROCEDURE Coalesce_Index__ (
   attr_       OUT VARCHAR2,
   index_name_ IN  VARCHAR2 )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Coalesce_Index__');
   Assert_SYS.Assert_Is_Index(index_name_);
   --@ApproveDynamicStatement(2006-01-05,utgulk)
   EXECUTE IMMEDIATE 'ALTER INDEX "'||index_name_||'" COALESCE ';
   DELETE FROM database_sys_oracle_index_tab WHERE index_name = index_name_;
   attr_ := Get_Oracle_Index_Attr___(index_name_);
END Coalesce_Index__;


FUNCTION Get_Buffer_Pool__ (
   object_name_ IN  VARCHAR2,
   object_type_ IN  VARCHAR2 ) RETURN VARCHAR2
IS
   buffer_pool_ VARCHAR2(30);

   CURSOR get_Table IS
SELECT buffer_pool
FROM   user_tables
WHERE  table_name = object_name_;

   CURSOR get_index IS
SELECT buffer_pool
FROM   user_indexes
WHERE  index_name = object_name_;

BEGIN
   IF    (object_type_ = 'TABLE') THEN
      OPEN  get_table;
      FETCH get_table INTO buffer_pool_;
      CLOSE get_table;
   ELSIF (object_type_ = 'INDEX') THEN
      OPEN  get_index;
      FETCH get_index INTO buffer_pool_;
      CLOSE get_index;
   END IF;
   RETURN buffer_pool_;
END Get_Buffer_Pool__;


FUNCTION Get_Extents__ (
   segment_name_ IN  VARCHAR2,
   segment_type_ IN VARCHAR2 ) RETURN NUMBER
IS
   extents_ NUMBER;

   CURSOR get_extent IS
SELECT extents
FROM   user_segments
WHERE  segment_name = segment_name_
AND    segment_type = segment_type_;

BEGIN
   OPEN  get_extent;
   FETCH get_extent INTO extents_;
   CLOSE get_extent;
   RETURN extents_;
END Get_Extents__;


FUNCTION Get_Initialization_Parameter__ (
   parameter_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   CURSOR get_parameter IS
   SELECT value
     FROM nls_instance_parameters
    WHERE parameter = parameter_;

   value_  nls_instance_parameters.value%TYPE;
BEGIN
   OPEN  get_parameter;
   FETCH get_parameter INTO value_;
   CLOSE get_parameter;
   IF parameter_ = 'NLS_CALENDAR' THEN
      value_ := nvl(value_, 'GREGORIAN');
   END IF;
   RETURN(value_);
END Get_Initialization_Parameter__;


FUNCTION Get_Last_Analyzed__ (
   object_name_ IN  VARCHAR2,
   object_type_ IN  VARCHAR2 ) RETURN DATE
IS
   last_analyzed_ DATE;

   CURSOR get_Table IS
SELECT last_analyzed
FROM   user_tables
WHERE  table_name = object_name_;

   CURSOR get_index IS
SELECT last_analyzed
FROM   user_indexes
WHERE  index_name = object_name_;

BEGIN
   IF    (object_type_ = 'TABLE') THEN
      OPEN  get_table;
      FETCH get_table INTO last_analyzed_;
      CLOSE get_table;
   ELSIF (object_type_ = 'INDEX') THEN
      OPEN  get_index;
      FETCH get_index INTO last_analyzed_;
      CLOSE get_index;
   END IF;
   RETURN last_analyzed_;
END Get_Last_Analyzed__;


FUNCTION Is_Rowkey_Enabled__ (
   lu_   IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   IF (Dictionary_SYS.Get_Objkey_Info(lu_) = 'NONE') THEN
      RETURN(FALSE);
   END IF;
   CASE Installation_SYS.Get_Column_Nullable(Dictionary_SYS.Get_Base_Table_Name(lu_), 'ROWKEY')
   WHEN NULL THEN
      RETURN(NULL);
   WHEN 'N' THEN
      RETURN(TRUE);
   WHEN 'Y' THEN
      RETURN(FALSE);
   ELSE
      RETURN(NULL);
   END CASE;
END Is_Rowkey_Enabled__;


PROCEDURE Rebuild_Index__ (
   attr_       OUT VARCHAR2,
   index_name_ IN  VARCHAR2 )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Rebuild_Index__');
   Rebuild_Index___(attr_, index_name_);
END Rebuild_Index__;


PROCEDURE Rebuild_Indexes__ (
   percent_deleted_ IN NUMBER DEFAULT 20 )
IS
   attr_    VARCHAR2(2000);
   index_names_     oracle_object_type;
   lock_detected    EXCEPTION;
   PRAGMA           EXCEPTION_INIT(lock_detected, -54);
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Rebuild_Indexes__');
   SELECT index_name
   BULK   COLLECT INTO index_names_
   FROM   database_sys_oracle_index_tab
   WHERE  percent_deleted >= percent_deleted_;
   FOR i IN Nvl(index_names_.FIRST,1)..Nvl(index_names_.LAST,-1) LOOP
      Transaction_SYS.Log_Progress_Info('Rebuilding index ' || index_names_(i));
      BEGIN
         Rebuild_Index___(attr_, index_names_(i));
      EXCEPTION
         WHEN lock_detected THEN
            Transaction_SYS.Log_Status_Info('Rebuilding index ' || index_names_(i) || ' failed, due to blocking locks.', 'WARNING');
         WHEN OTHERS THEN
            Transaction_SYS.Log_Status_Info(Substr('Rebuilding index ' || index_names_(i) || ' failed, due to Oracle error ' || SQLERRM || '.',1,2000), 'WARNING');
      END;
   END LOOP;
   Transaction_SYS.Log_Progress_Info(' ');
END Rebuild_Indexes__;


PROCEDURE Validate_Index__ (
   attr_            OUT VARCHAR2,
   index_name_      IN  VARCHAR2,
   validation_date_ IN  DATE DEFAULT SYSDATE )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Validate_Index__');
   Validate_Index___(attr_, index_name_, validation_date_);
END Validate_Index__;


PROCEDURE Validate_Indexes__ (
   max_attempts_ IN NUMBER DEFAULT 5,
   sleep_before_retry_seconds_ IN NUMBER DEFAULT 10 )
IS
   attr_            VARCHAR2(2000);
   validation_date_ DATE := SYSDATE;
   index_names_     oracle_object_type;
   index_names_to_retry_ oracle_object_type;   
   lock_detected    EXCEPTION;
   PRAGMA           EXCEPTION_INIT(lock_detected, -54);
   
   total_indexes_to_validate_ NUMBER;
   completely_failed_indexes_ NUMBER := 0;
   attempt_ INTEGER := 1;
   has_indexes_to_validate_ BOOLEAN := TRUE;
   
   --max_attempts_ Number of times to retry validation of a locked index
   --sleep_before_retry_seconds_ Number of seconds to wait between each retry
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Validate_Indexes__');
   --Check the input parameters
   IF(NOT max_attempts_ > 0) THEN
      Error_SYS.Appl_General (service_, 'INVALID_MAX_ATTEMPTS: MAX_ATTEMPTS_ must be set to a number greater than zero, but it was set to :P1. Please change the parameters of the scheduled job and try again.', TO_CHAR(max_attempts_));
   END IF;
   IF (NOT sleep_before_retry_seconds_ >= 0) THEN
      Error_SYS.Appl_General (service_, 'INVALID_SLEEP_BEFORE_RETRY_SECONDS: SLEEP_BEFORE_RETRY_SECONDS_ must be set to a number greater than or equal to zero, but it was set to :P1. Please change the parameters of the scheduled job and try again.', TO_CHAR(max_attempts_));
   END IF;
   
   --@ApproveDynamicStatement(2006-02-15,pemase)
   EXECUTE IMMEDIATE 'TRUNCATE TABLE database_sys_oracle_index_tab';
   
   SELECT index_name
   BULK   COLLECT INTO index_names_
   FROM   user_indexes
   WHERE  nvl(temporary, 'N') = 'N'
   AND    index_type NOT IN ('IOT - TOP','LOB');
   
   Transaction_SYS.Log_Status_Info('Total number of indexes to validate: ' || TO_CHAR(index_names_.count) || '. Number of attempts for locked indexes: ' || TO_CHAR(max_attempts_) || '. Wait between attempts: ' || TO_CHAR(sleep_before_retry_seconds_) || ' second(s)', 'INFO');

   WHILE ((attempt_ <= max_attempts_) AND (has_indexes_to_validate_))
   LOOP
      --Clear up the retry index list
      has_indexes_to_validate_ := FALSE;
      index_names_to_retry_.delete();      
      
      total_indexes_to_validate_ := index_names_.count;      
      Transaction_SYS.Log_Status_Info('Starting attempt ' || attempt_ || ' to validate ' || TO_CHAR(total_indexes_to_validate_) || ' indexes.', 'INFO');
      
      FOR current_index_to_validate_ IN index_names_.FIRST..index_names_.LAST LOOP
         Transaction_SYS.Log_Progress_Info ('Validating index ' || index_names_(current_index_to_validate_) || ' (' || TO_CHAR(current_index_to_validate_) || ' of ' || TO_CHAR(total_indexes_to_validate_) || ' indexes)');

         --Try to validate the index and handle any errors
         BEGIN
            Validate_Index___(attr_, index_names_(current_index_to_validate_), validation_date_);
         EXCEPTION
            WHEN lock_detected THEN
               IF (attempt_ < max_attempts_) THEN
                    Transaction_SYS.Log_Status_Info('Validating index ' || index_names_(current_index_to_validate_) || ' failed, due to blocking locks. Another ' || TO_CHAR(max_attempts_ - attempt_) || ' attempt(s) to validate the indexed will be made.', 'INFO');
               ELSE
                    Transaction_SYS.Log_Status_Info('Validating index ' || index_names_(current_index_to_validate_) || ' failed ' || max_attempts_ || ' validation attempts, due to blocking locks. No further validation attempts will be made.', 'WARNING');
                    completely_failed_indexes_ := completely_failed_indexes_ + 1;
               END IF;               
               index_names_to_retry_(index_names_to_retry_.count() + 1) := index_names_(current_index_to_validate_); --add to the retry list
               has_indexes_to_validate_ := TRUE;
            WHEN OTHERS THEN
               Transaction_SYS.Log_Status_Info(Substr('Validating index ' || index_names_(current_index_to_validate_) || ' failed, due to Oracle error ' || SQLERRM || '.',1,2000), 'WARNING');
               completely_failed_indexes_ := completely_failed_indexes_ + 1;
         END;
      END LOOP;
      
      --Update the status and sleep if there are more runs to do
      IF(has_indexes_to_validate_ AND (attempt_ < max_attempts_)) THEN
         Transaction_SYS.Log_Status_Info('Finished attempt ' || attempt_ || ' of ' || max_attempts_ || ' with ' || TO_CHAR(index_names_to_retry_.count()) || ' locked indexes remaining. Waiting for ' || TO_CHAR(sleep_before_retry_seconds_) || ' second(s) before next attempt.', 'INFO');
         DBMS_LOCK.sleep(sleep_before_retry_seconds_);
      END IF;
      
      index_names_ := index_names_to_retry_;
      attempt_ := attempt_ + 1;
   END LOOP;
   
   IF(completely_failed_indexes_ > 0) THEN
      Transaction_SYS.Log_Status_Info('Validation of indexes finished with ' || TO_CHAR(completely_failed_indexes_) || ' indexes failing validation.', 'WARNING');
   ELSE
      Transaction_SYS.Log_Status_Info('Successfully completed validation of all indexes after ' || TO_CHAR(attempt_ - 1) || ' validation attempts', 'INFO');
   END IF;
   Transaction_SYS.Log_Progress_Info (' ');
END Validate_Indexes__;


PROCEDURE Execute_Analyze_Schema__ (
   attr_ IN VARCHAR2 )
IS
   ptr_                    NUMBER;
   name_                   VARCHAR2(30);
   value_                  VARCHAR2(2000);
   schema_                 VARCHAR2(30);
   method_                 VARCHAR2(50);
   appowner_               VARCHAR2(5);
   dictionary_             VARCHAR2(5);
   estimate_percent_       NUMBER;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Execute_Analyze_Schema__');
   -- Retrieve parameters from the attribute string
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      IF (name_ = 'SCHEMA') THEN
         schema_ := value_;
      ELSIF (name_ = 'ESTIMATE_PERCENT') THEN
         estimate_percent_ := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'METHOD') THEN
         method_ := value_;
      ELSIF (name_ = 'APPOWNER') THEN
         appowner_ := value_;
      ELSIF (name_ = 'DICTIONARY') THEN
         dictionary_ := value_;
      END IF;
   END LOOP;
   IF (schema_ = 'IFSAPPOWNER') THEN
      schema_ := Fnd_Session_API.Get_App_Owner;
   ELSIF (schema_ = 'IFSIALOWNER') THEN
      schema_ := Fnd_Setting_API.Get_Value('IAL_USER');
   END IF;
   IF (Nvl(appowner_, 'TRUE') = 'TRUE') THEN
      Analyze_Schema___(schema_, method_, estimate_percent_);
   END IF;
   IF (Nvl(dictionary_, 'FALSE') = 'TRUE') THEN
      Analyze_Dictionary___(method_);
   END IF;
END Execute_Analyze_Schema__;


PROCEDURE Execute_Analyze_Others__ (
   system_   IN VARCHAR2 DEFAULT 'TRUE',
   static_   IN VARCHAR2 DEFAULT 'TRUE',
   interval_ IN NUMBER   DEFAULT 60 )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Execute_Analyze_Others__');
   --
   -- Analyze system statistics
   --
   IF (system_ = 'TRUE') THEN
      Transaction_SYS.Log_Progress_Info ('Analyzing system statistics ');
      BEGIN
         --@ApproveDynamicStatement(2005-02-15,pemase)
         EXECUTE IMMEDIATE 'BEGIN sys.Gather_System_Statistics(:interval); END;' USING interval_;
      EXCEPTION
         WHEN OTHERS THEN
            Transaction_SYS.Log_Status_Info(Substr('Analyzing system statistics objects failed, due to Oracle error ' || SQLERRM || '.',1,2000), 'WARNING');
      END;
   END IF;
   --
   -- Analyze static tables statistics
   --
   IF (static_ = 'TRUE') THEN
      Transaction_SYS.Log_Progress_Info ('Analyzing fixed objects ');
      BEGIN
         Dbms_Stats.Gather_Fixed_Objects_Stats;
      EXCEPTION
         WHEN OTHERS THEN
            Transaction_SYS.Log_Status_Info(Substr('Analyzing fixed objects failed, due to Oracle error ' || SQLERRM || '.',1,2000), 'WARNING');
      END;
   END IF;
   Transaction_SYS.Log_Progress_Info(' ');
END Execute_Analyze_Others__;


FUNCTION Start_SQL_Trace__ (
   enable_ IN VARCHAR2,
   identifier_ IN VARCHAR2 DEFAULT NULL) RETURN VARCHAR2
IS
   value_          v$diag_info.value%TYPE;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Start_SQL_Trace__');
   Set_Sql_Trace__(enable_, identifier_);
   SELECT value
   INTO value_
   FROM   v$diag_info
   WHERE  name = 'Diag Trace';
   RETURN   value_;
END Start_SQL_Trace__;


PROCEDURE Set_Sql_Trace__ (
   enable_ IN VARCHAR2,
   identifier_ IN VARCHAR2 DEFAULT NULL)
IS
   --label_   VARCHAR2(60);
   FUNCTION Check_Allowed___ RETURN BOOLEAN
   IS
      off_ VARCHAR2(3) := 'OFF';
   BEGIN
      RETURN NVL(Fnd_Setting_API.Get_Value('SQL_TRACE'),off_) <> off_;
   END Check_Allowed___;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Set_Sql_Trace__');
   -- Check if SQL trace is allowed
   IF ( Check_Allowed___ ) THEN
      -- Set identifier that could be used with TRCSESS
      Dbms_Session.Set_Identifier(identifier_);
      IF enable_ = 'TRUE' THEN
         --@ApproveDynamicStatement(2006-05-11,haarse)
         EXECUTE IMMEDIATE q'[ALTER SESSION SET TRACEFILE_IDENTIFIER = ifs]';
         --@ApproveDynamicStatement(2006-02-15,pemase)
         EXECUTE IMMEDIATE 'ALTER SESSION SET TIMED_STATISTICS = TRUE';
         --@ApproveDynamicStatement(2006-02-15,pemase)
         EXECUTE IMMEDIATE q'[ALTER SESSION SET EVENTS '10046 trace name context forever, level 12']';
      ELSIF enable_ = 'FALSE' THEN
         --@ApproveDynamicStatement(2006-02-15,pemase)
         EXECUTE IMMEDIATE q'[ALTER SESSION SET EVENTS '10046 trace name context off']';
--         --@ApproveDynamicStatement(2006-05-11,haarse)
--         EXECUTE IMMEDIATE q'[ALTER SESSION SET TRACEFILE_IDENTIFIER = '']';
      ELSE
         Error_SYS.Appl_General(service_, 'ERRORPARAMSQLTRACE: Incorrect parameter :P1 in call to Set_Sql_Trace__!', enable_);
      END IF;
   END IF;
END Set_Sql_Trace__;


PROCEDURE Set_Commit_In_Procedure__ (
   enable_ IN VARCHAR2 )
IS
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Set_Commit_In_Procedure__');
   IF enable_ = 'TRUE' THEN
      --@ApproveDynamicStatement(2006-02-15,pemase)
      EXECUTE IMMEDIATE 'ALTER SESSION ENABLE COMMIT IN PROCEDURE';
   ELSIF enable_ = 'FALSE' THEN
      --@ApproveDynamicStatement(2006-02-15,pemase)
      EXECUTE IMMEDIATE 'ALTER SESSION DISABLE COMMIT IN PROCEDURE';
   ELSE
      Error_SYS.Appl_General(service_, 'ERRORPARAMCOMMITPROC: Incorrect parameter :P1 in call to Set_Commit_In_Procedure__!', enable_);
   END IF;
END Set_Commit_In_Procedure__;


PROCEDURE Cleanup_Temporary_Data__
IS
   CURSOR get_table IS
      SELECT table_name, column_name, age
      FROM cleanup_temporary_data_tab;
BEGIN
   General_SYS.Check_Security(service_, 'DATABASE_SYS', 'Cleanup_Temporary_Data__');
   FOR rec_ IN get_table LOOP
      BEGIN
         --@ApproveDynamicStatement(2014-06-27,haarse)
         EXECUTE IMMEDIATE 'DELETE FROM '||rec_.table_name||' WHERE '||rec_.column_name||' <= SYSDATE - '||rec_.age;
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;
   END LOOP;
END Cleanup_Temporary_Data__;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC IMPLEMENTATION METHODS ---------------------
-----------------------------------------------------------------------------

PROCEDURE Analyze_Dictionary___ (
   method_           IN VARCHAR2 DEFAULT 'AUTOMATIC' )
IS
BEGIN
   CASE
      WHEN method_ = 'DELETE' THEN
         Transaction_SYS.Log_Progress_Info ('Removing Dictionary statistics ');
         BEGIN
            Dbms_Stats.Delete_Dictionary_Stats;
         EXCEPTION
            WHEN OTHERS THEN
               Transaction_SYS.Log_Status_Info(Substr('Removing Dictionary statistics failed, due to Oracle error ' || SQLERRM || '.',1,2000), 'WARNING');
               RAISE;
         END;
      ELSE
         Transaction_SYS.Log_Progress_Info ('Analyzing Dictionary objects ');
         BEGIN
            Dbms_Stats.Gather_Dictionary_Stats;
         EXCEPTION
            WHEN OTHERS THEN
               Transaction_SYS.Log_Status_Info(Substr('Gathering of Dictionary statistics failed, due to Oracle error ' || SQLERRM || '.',1,2000), 'WARNING');
               RAISE;
         END;
   END CASE;
   Transaction_SYS.Log_Progress_Info(' ');
END Analyze_Dictionary___;


PROCEDURE Analyze_Schema___ (
   schema_           IN VARCHAR2 DEFAULT USER,
   method_           IN VARCHAR2 DEFAULT 'AUTOMATIC',
   estimate_percent_ IN NUMBER   DEFAULT NULL )
IS
   percent_          NUMBER := 0;
BEGIN
   IF method_ = 'DELETE' THEN
      BEGIN
         Transaction_SYS.Log_Progress_Info('Statistics deletion job in progress.');
         Dbms_Stats.Delete_Schema_Stats(schema_);
         Transaction_SYS.Log_Status_Info(Get_job_info___,'INFO');
         Transaction_SYS.Log_Status_Info('Optimizer will use Rule Based Optimization until new statistics are gathered.','INFO');
      EXCEPTION
         WHEN OTHERS THEN
            Transaction_SYS.Log_Status_Info(Substr('Statistics deletion job failed, due to Oracle error ' || SQLERRM || '.',1,2000), 'WARNING');
      END;
   ELSE
      IF method_ = 'AUTOMATIC' THEN
         Calculate_Percent___(percent_);
      ELSIF method_ = 'COMPUTE' THEN
         percent_ := NULL;
      ELSIF method_ = 'ESTIMATE' THEN
         percent_ := estimate_percent_;
      END IF;
      BEGIN
         Transaction_SYS.Log_Progress_Info('Gather statistics job in progress.');
         Dbms_Stats.Gather_Schema_Stats(schema_,percent_);
         Transaction_SYS.Log_Status_Info(Get_job_info___,'INFO');
      EXCEPTION
         WHEN OTHERS THEN
            Transaction_SYS.Log_Status_Info(Substr('Gather statistics job failed, due to Oracle error ' || SQLERRM || '.',1,2000), 'WARNING');
      END;
   END IF;
   Transaction_SYS.Log_Progress_Info(' ');
END Analyze_Schema___;


PROCEDURE Calculate_Percent___ (
   percent_ OUT NUMBER )
IS
BEGIN
   percent_ := Dbms_Stats.Auto_Sample_Size;
END Calculate_Percent___;


PROCEDURE Gather_Index_Statistics___ (
   method_           IN VARCHAR2 DEFAULT 'AUTOMATIC',
   schema_           IN VARCHAR2 DEFAULT USER,
   index_name_       IN VARCHAR2,
   estimate_percent_ IN NUMBER   DEFAULT NULL )
IS
   temporary_        VARCHAR2(10);
   percent_          NUMBER := estimate_percent_;
   CURSOR get_index IS
      SELECT Nvl(temporary, 'N')
      FROM   Dba_indexes
      WHERE  index_name = index_name_;
BEGIN
   OPEN  get_index;
   FETCH get_index INTO temporary_;
   CLOSE get_index;
   IF temporary_ != 'Y' THEN -- Do not gather statistics for temporary tables.
      IF method_ = 'DELETE' THEN
         Dbms_Stats.Delete_Index_Stats(ownname          => schema_,
                                       indname          => index_name_);
      ELSE
         IF method_ IN ('AUTOMATIC', 'COMPUTE') THEN
            percent_ := NULL;
         END IF;
         Dbms_Stats.Gather_Index_Stats(ownname          => schema_,
                                       indname          => index_name_,
                                       estimate_percent => percent_);
      END IF;
   END IF;
END Gather_Index_Statistics___;


PROCEDURE Gather_Table_Statistics___ (
   method_           IN VARCHAR2 DEFAULT 'AUTOMATIC',
   schema_           IN VARCHAR2 DEFAULT USER,
   table_name_       IN VARCHAR2,
   estimate_percent_ IN NUMBER   DEFAULT NULL,
   block_sample_     IN BOOLEAN  DEFAULT FALSE,
   cascade_          IN BOOLEAN  DEFAULT FALSE )
IS
   percent_          NUMBER;
   temporary_        VARCHAR2(10);
   CURSOR get_table IS
      SELECT Nvl(temporary, 'N')
      FROM   Dba_tables
      WHERE  table_name = table_name_;
BEGIN
   OPEN  get_table;
   FETCH get_table INTO temporary_;
   CLOSE get_table;
   IF temporary_ != 'Y' THEN -- Do not gather statistics for temporary tables.
      IF method_ = 'DELETE' THEN
         Dbms_Stats.Delete_Table_Stats(ownname          => schema_,
                                       tabname          => table_name_,
                                       cascade_indexes  => cascade_);
      ELSE
         IF method_ = 'AUTOMATIC' THEN
            Calculate_Percent___(percent_);
         ELSIF method_ = 'COMPUTE' THEN
            percent_ := NULL;
         ELSIF method_ = 'ESTIMATE' THEN
            percent_ := estimate_percent_;
         ELSIF method_ = 'SCHEMA' THEN
            percent_ := estimate_percent_; -- No calculation has to be done, already been taken care of in Analyze_Schema
         END IF;
$IF Dbms_Db_Version.ver_le_10 $THEN
         -- No histograms for Oracle10g and lower versions
         Dbms_Stats.Gather_Table_Stats(ownname          => schema_,
                                       tabname          => table_name_,
                                       estimate_percent => percent_,
                                       block_sample     => block_sample_,
                                       cascade          => cascade_,
                                       method_opt       => 'for all columns size 1');
$ELSE
         -- Histograms for Oracle11g and above higher versions
         Dbms_Stats.Gather_Table_Stats(ownname          => schema_,
                                       tabname          => table_name_,
                                       estimate_percent => percent_,
                                       block_sample     => block_sample_,
                                       cascade          => cascade_);
$END
      END IF;
   END IF;
END Gather_Table_Statistics___;


FUNCTION Get_Oracle_Index_Attr___ (
   index_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   attr_    VARCHAR2(2000);
   CURSOR get_oracle_index IS
      SELECT index_name,
             validation_timestamp,
             validation_date,
             percent_deleted,
             distinctivness,
             allocated_space,
             currently_used_space,
             percent_used,
             recommendation,
             blevel_recommendation
      FROM   oracle_indexes
      WHERE  index_name = index_name_;
BEGIN
   FOR rec IN get_oracle_index LOOP
      Client_SYS.Clear_Attr(attr_);
      Client_SYS.Add_To_Attr('INDEX_NAME', rec.index_name, attr_);
      Client_SYS.Add_To_Attr('VALIDATION_TIMESTAMP', rec.validation_timestamp, attr_);
      Client_SYS.Add_To_Attr('VALIDATION_DATE', rec.validation_date, attr_);
      Client_SYS.Add_To_Attr('PERCENT_DELETED', rec.percent_deleted, attr_);
      Client_SYS.Add_To_Attr('DISTINCTIVNESS', rec.distinctivness, attr_);
      Client_SYS.Add_To_Attr('ALLOCATED_SPACE', rec.allocated_space, attr_);
      Client_SYS.Add_To_Attr('CURRENTLY_USED_SPACE', rec.currently_used_space, attr_);
      Client_SYS.Add_To_Attr('RECOMMENDATION', rec.recommendation, attr_);
      Client_SYS.Add_To_Attr('PERCENT_USED', rec.percent_used, attr_);
      Client_SYS.Add_To_Attr('BLEVEL_RECOMMENDATION', rec.blevel_recommendation, attr_);
   END LOOP;
   RETURN(attr_);
END Get_Oracle_Index_Attr___;


FUNCTION Get_Instance_Values___ RETURN sys.v_$instance%ROWTYPE
IS
   instance_rec_                  sys.v_$instance%ROWTYPE;
   CURSOR get_instance IS
      SELECT * --instance_name, host_name, version are the interesting columns right now
      FROM sys.v_$instance;
BEGIN
   OPEN  get_instance;
   FETCH get_instance INTO instance_rec_;
   CLOSE get_instance;
   RETURN(instance_rec_);
END Get_Instance_Values___;


PROCEDURE Rebuild_Index___ (
   attr_       OUT VARCHAR2,
   index_name_ IN  VARCHAR2 )
IS
   stmt_          VARCHAR2(200) := 'ALTER INDEX "'||index_name_||'" REBUILD ';
   stmt2_         VARCHAR2(200) := stmt_;
   online_error   EXCEPTION;
   PRAGMA         EXCEPTION_INIT(online_error, -1450);

   PROCEDURE rebuild___ (
      statement_ IN VARCHAR2 )
   IS
   BEGIN
      Assert_SYS.Assert_Is_Index(index_name_);
      --@ApproveDynamicStatement(2006-01-05,utgulk)
      EXECUTE IMMEDIATE statement_;
      DELETE FROM database_sys_oracle_index_tab WHERE index_name = index_name_;
      attr_ := Get_Oracle_Index_Attr___(index_name_);
   END rebuild___;
BEGIN
   IF Installation_SYS.Is_Option_Available('Online Index Build') THEN
      stmt_ := stmt_ || 'ONLINE ';
   END IF;
   rebuild___(stmt_);
EXCEPTION
   WHEN online_error THEN
      rebuild___(stmt2_);
END Rebuild_Index___;


PROCEDURE Rebuild_Unusable_Indexes___(
   table_name_  IN VARCHAR2,
   show_info_   IN BOOLEAN  DEFAULT TRUE ) 
IS
   CURSOR get_indexes IS
      SELECT index_name, index_type
      FROM   user_indexes
      WHERE  table_name = table_name_
      AND    status = 'UNUSABLE';
BEGIN
   FOR rec IN get_indexes LOOP 
      IF (rec.index_type = 'DOMAIN') THEN
         -- Maybe submit a rebuild of Search Domain indexes
         NULL;
      ELSE 
         Installation_SYS.Rebuild_Index(rec.index_name, show_info_);
      END IF;
   END LOOP;
END Rebuild_Unusable_Indexes___;


PROCEDURE Validate_Character_Set___ (
   character_set_    IN VARCHAR2 )
IS
   temp_ VARCHAR2(100) := 'QwE'; -- Dummy string
BEGIN
   IF character_set_ IS NULL THEN
      RAISE no_data_found;
   END IF;
   temp_ := convert(temp_, character_set_);
EXCEPTION
   WHEN no_data_found THEN
      Error_SYS.Appl_General(service_, 'NO_CHARACTER_SET: A valid character set/file encoding must be used, NULL is not an acceptable value.');
   WHEN OTHERS THEN
      Error_SYS.Appl_General(service_, 'CHARACTER_SET: The character set/file encoding :P1 is not supported by Oracle.', character_set_);
END Validate_Character_Set___;


PROCEDURE Validate_Index___ (
   attr_             OUT VARCHAR2,
   index_name_       IN  VARCHAR2,
   validation_date_  IN  DATE DEFAULT SYSDATE )
IS
   recommendation_   VARCHAR2(100);
   CURSOR get_index IS
   SELECT  del_lf_rows*100/decode(lf_rows,0,1,lf_rows)               percent_deleted,
           (lf_rows-distinct_keys)*100/decode(lf_rows,0,1,lf_rows)   distinctiveness,
           btree_space                                               allocated_space,
           used_space                                                currently_used_space,
           pct_used                                                  percent_used
   FROM    SYS.index_stats
   WHERE   name = index_name_;
   ind_    get_index%ROWTYPE;
BEGIN
   Assert_SYS.Assert_Is_Index(index_name_);
   --@ApproveDynamicStatement(2006-01-05,utgulk)
   EXECUTE IMMEDIATE 'ANALYZE INDEX '||index_name_||' VALIDATE STRUCTURE';
   --
   DELETE FROM database_sys_oracle_index_tab WHERE index_name = index_name_;
   OPEN  get_index;
   FETCH get_index INTO ind_;
   IF get_index%FOUND THEN
      IF Nvl(ind_.percent_deleted, 0) >= 20  THEN
         recommendation_ := 'Rebuild index.';
      ELSIF Nvl(ind_.percent_deleted, 0) >= 10  THEN
         recommendation_ := 'Index is candidate to rebuild.';
      ELSE
         recommendation_ := 'No rebuild of index needed.';
      END IF;
      INSERT INTO database_sys_oracle_index_tab (
      index_name,
      validation_date,
      validation_timestamp,
      percent_deleted,
      distinctivness,
      allocated_space,
      currently_used_space,
      percent_used,
      recommendation)
      VALUES (
      index_name_,
      validation_date_,
      SYSDATE,
      ind_.percent_deleted,
      ind_.distinctiveness,
      ind_.allocated_space,
      ind_.currently_used_space,
      ind_.percent_used,
      recommendation_);
   END IF;
   CLOSE get_index;
   attr_ := Get_Oracle_Index_Attr___(index_name_);
END Validate_Index___;


FUNCTION Get_Job_Info___ RETURN VARCHAR2
IS
   temp_ VARCHAR2(1000);
   CURSOR get_info IS
      SELECT info
      FROM ( SELECT substr(message,1,1000) AS info
               FROM v$session_longops t,v$session s
              WHERE t.sid=s.sid 
                AND t.serial# = s.serial#
                AND s.audsid = sys_context('USERENV','SESSIONID')
                AND t.units='Objects'
           ORDER BY t.last_update_time DESC )
       WHERE ROWNUM = 1;
BEGIN
   OPEN get_info;
   FETCH get_info INTO temp_;
   CLOSE get_info;
   RETURN nvl(temp_,'Job Completed');
END Get_Job_Info___;


PROCEDURE Execute_Task___ (
   table_name_     IN VARCHAR2,
   stmt_           IN VARCHAR2,
   chunk_size_     IN NUMBER DEFAULT 10000,
   parallel_level_ IN NUMBER DEFAULT 10,
   lu_             IN VARCHAR2)
IS
   task_   VARCHAR2(30) := Dbms_Parallel_Execute.Generate_Task_Name;
   status_ NUMBER;
   trg_count_     NUMBER;
   error_message_ VARCHAR2(32000);
   CURSOR get_active_triggers(table_name_ VARCHAR2) IS
      SELECT COUNT(*)
      FROM   dba_triggers t
      WHERE  t.table_name = table_name_
      AND    t.status = 'ENABLED'
      AND    t.table_owner = Fnd_Session_API.Get_App_Owner;
   CURSOR get_parallel_chunks IS
      SELECT error_message
      FROM   USER_PARALLEL_EXECUTE_CHUNKS t
      WHERE  error_message IS NOT NULL;

   PROCEDURE Drop_Tasks___ (
      table_name_ IN VARCHAR2 )
   IS
      CURSOR get_task IS
         SELECT task_name
         FROM user_parallel_execute_tasks
         WHERE table_name = upper(table_name_);
         --WHERE status IN
   BEGIN
      FOR rec IN get_task LOOP
         Dbms_Parallel_Execute.Drop_Task(rec.task_name);
      END LOOP;
   END Drop_Tasks___;

BEGIN
   Transaction_SYS.Log_Progress_Info('Dropping old tasks');
   Drop_Tasks___(table_name_);
   Transaction_SYS.Log_Progress_Info('Creating task');
   Dbms_Parallel_Execute.Create_Task(task_name => task_);
   Transaction_SYS.Log_Progress_Info('Creating chunks');
   Dbms_Parallel_Execute.Create_Chunks_By_Rowid(task_name   => task_,
                                               table_owner => Fnd_Session_API.Get_App_Owner,
                                               table_name  => table_name_,
                                               by_row      => TRUE,
                                               chunk_size  => chunk_size_);
--  stmt_ := 'UPDATE Test_TAB SET rowkey = sys_guid() WHERE rowkey IS NULL AND rowid BETWEEN :start_id AND :end_id';
   Transaction_SYS.Log_Progress_Info('Executing task');
   Dbms_Parallel_Execute.Run_Task(task_name      => task_,
                                  sql_stmt       => stmt_,
                                  language_flag  => Dbms_Sql.NATIVE,
                                  parallel_level => parallel_level_);
   Transaction_SYS.Log_Progress_Info('Checking status');
   status_ := Dbms_Parallel_Execute.Task_Status(task_);
   IF (status_ IN (Dbms_Parallel_Execute.FINISHED_WITH_ERROR, Dbms_Parallel_Execute.CRASHED)) THEN
      Transaction_SYS.Log_Progress_Info('Resume task');
      Dbms_Parallel_Execute.Resume_Task(task_);
      status_ := Dbms_Parallel_Execute.Task_Status(task_);
   END IF;
   IF (status_ != Dbms_Parallel_Execute.FINISHED) THEN
      IF Fnd_Event_API.Check_Custom_Event(table_name_) OR History_Setting_Attribute_API.Check_History_Enable(table_name_) THEN
         Error_SYS.Appl_General(service_, 'TASK_TRGERROR: RowKey activation failed due to active triggers on table :P1, please check for Custom Events or History Log Settings on logical unit :P2.', table_name_, lu_ );
      ELSE
         OPEN get_parallel_chunks;
         FETCH get_parallel_chunks INTO error_message_;
         IF get_parallel_chunks%FOUND THEN
            CLOSE get_parallel_chunks;
            error_message_ := crlf_||error_message_;
            Error_SYS.Appl_General(service_, 'TASK_CHUNKERROR: RowKey activation on table :P1 failed due to unexpected error. Please take action on error :P2', table_name_, error_message_);
         ELSE
            CLOSE get_parallel_chunks;
            OPEN get_active_triggers(table_name_);
            FETCH get_active_triggers INTO trg_count_;
            CLOSE get_active_triggers;
            IF(trg_count_ > 0) THEN
               Error_SYS.Appl_General(service_, 'TASK_TRGERROR2: RowKey activation failed probably due to active triggers on table :P1, please disable triggers.', table_name_);
            ELSE
               Error_SYS.Appl_General(service_, 'TASK_ERROR: The task :P1 finished with an unknown error.', task_);
            END IF;
         END IF;
      END IF;
   END IF;
   IF (status_ = Dbms_Parallel_Execute.FINISHED) THEN
      Transaction_SYS.Log_Progress_Info('Dropping task');
      Dbms_Parallel_Execute.Drop_Task(task_);
      Transaction_SYS.Log_Progress_Info('Finish task');
   END IF;
EXCEPTION
   WHEN OTHERS THEN
      Transaction_SYS.Log_Status_Info('Error when executing task');
      Dbms_Parallel_Execute.Drop_Task(task_);
      RAISE;
END Execute_Task___;


FUNCTION Get_Init_Ora_Parameter___ (
   parameter_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   CURSOR get_param IS
   SELECT value
     FROM v$parameter
    WHERE name = parameter_;

   value_  v$parameter.value%TYPE;
BEGIN
   OPEN  get_param;
   FETCH get_param INTO value_;
   CLOSE get_param;
   RETURN(value_);
END Get_Init_Ora_Parameter___;


PROCEDURE Grant_All_Hud_Pres_Objects___ (
   role_  IN VARCHAR2 )
IS
   CURSOR all_hud_pres_objects IS
      SELECT po_id
        FROM pres_object_tab
       WHERE module = 'FNDBAS'
         AND pres_object_type IN ('HUD', 'LOBBY');
BEGIN
   Log_SYS.Fnd_Trace_(Log_SYS.info_, 'Grant HUD/LOBBY related Presentation Objects to ' || role_);
   -- Grant: EE_HUD_DESIGN/EE_LOBBY_DESIGN
   --        What ever available will be granted and
   --        the other will be ignored.
   Pres_Object_Util_API.Grant_Pres_Object('EE_HUD_DESIGN', role_);
   Pres_Object_Util_API.Grant_Pres_Object('EE_LOBBY_DESIGN', role_);
   --
   -- Grant: All the Presentation Objects of type HUD/LOBBY
   BEGIN
      FOR po IN all_hud_pres_objects LOOP
         BEGIN
            IF (Pres_Object_Util_API.Get_Grant_Info(po.po_id, role_) != 'GRANTED') THEN
               Pres_Object_Util_API.Grant_Pres_Object( po.po_id, role_);
            END IF;
         EXCEPTION
            WHEN OTHERS THEN
               Log_SYS.Fnd_Trace_(Log_SYS.error_, 'Error when trying to grant PO ID: '||po.po_id);
         END;
      END LOOP;
   END;
END Grant_All_Hud_Pres_Objects___;


FUNCTION Has_Domain_Index___ (
   table_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   index_name_ VARCHAR2(30);
   CURSOR check_domain_index IS
      SELECT index_name
      FROM   user_indexes
      WHERE  table_name = table_name_
      AND    index_type = 'DOMAIN';
BEGIN
   OPEN check_domain_index;
   FETCH check_domain_index INTO index_name_;
   CLOSE check_domain_index;
   IF (index_name_ IS NOT NULL) THEN 
      RETURN TRUE;
   ELSE
      RETURN FALSE;
   END IF;
END Has_Domain_Index___;


FUNCTION Is_Unicode_Character_Set___ (
   character_set_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   --
   CURSOR get_charset IS
   SELECT 1
  FROM v$nls_valid_values t
 WHERE parameter = 'CHARACTERSET'
   AND value LIKE '%UTF%'
   AND isdeprecated = 'FALSE'
   AND value = character_set_;
   dummy_    NUMBER;
BEGIN
   OPEN get_charset;
   FETCH get_charset INTO dummy_;
   CLOSE get_charset;
   IF (dummy_ = 1) THEN
      RETURN(TRUE);
   ELSE
      RETURN(FALSE);
   END IF;
END Is_Unicode_Character_Set___;


PROCEDURE Update_Rowkey___ (
   table_name_ IN VARCHAR2,
   lu_         IN VARCHAR2 )
IS
   count_   NUMBER;
   stmt_    VARCHAR2(32000) := 'UPDATE /*+ ROWID (dda) */ ' || table_name_ || ' SET rowkey = rowid WHERE rowkey IS NULL';
   stmt2_   VARCHAR2(32000) := 'SELECT count(*) FROM ' || table_name_ || ' WHERE rowkey IS NULL';
BEGIN
   Assert_SYS.Assert_Is_Table(table_name_);
   -- Check if there exists rowkey with null
   --@ApproveDynamicStatement(2014-06-27,haarse)
   EXECUTE IMMEDIATE stmt2_ INTO count_;
   -- Only update if there exists rowkey with null
   IF (count_ > 0) THEN
      stmt_ := stmt_ || ' AND rowid BETWEEN :start_id AND :end_id';
      Transaction_SYS.Log_Progress_Info('Before executing task');
      Execute_Task___(table_name_ => table_name_,
                      stmt_ => stmt_,
                      chunk_size_ => 1000,
                      lu_ => lu_);
      Transaction_SYS.Log_Progress_Info('After executing task');
   END IF;
END Update_Rowkey___;


PROCEDURE Alter_Table_Rowkey___ (
   table_name_ IN VARCHAR2,
   compile_    IN VARCHAR2 )
IS
   column_  Installation_SYS.Colrec;
BEGIN
   Transaction_SYS.Log_Progress_Info('Before ALTERing ROWKEY.');
   column_ := Set_Column_Values('ROWKEY', 'VARCHAR2(50)', 'N', ' sys_guid()', NULL, 'D');
   Alter_Table_Column(table_name_, 'MODIFY', column_);
   IF compile_ = 'TRUE' THEN
      Transaction_SYS.Log_Progress_Info('Before compile of invalid objects');
      Database_SYS.Compile_All_Invalid_Objects;
      Transaction_SYS.Log_Progress_Info('After compile of invalid objects');
   END IF;
END Alter_Table_Rowkey___;

-----------------------------------------------------------------------------
-------------------- FOUNDATION1 METHODS ------------------------------------
-----------------------------------------------------------------------------


--@IgnoreMissingSysinit
PROCEDURE Init
IS
   
   PROCEDURE Base
   IS
   BEGIN
      NULL;
   END Base;

BEGIN
   Base;
END Init;

BEGIN
   Init;
END DATABASE_SYS;